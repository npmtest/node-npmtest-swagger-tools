{"/home/travis/build/npmtest/node-npmtest-swagger-tools/test.js":"/* istanbul instrument in package npmtest_swagger_tools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/lib.npmtest_swagger_tools.js":"/* istanbul instrument in package npmtest_swagger_tools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_swagger_tools = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_swagger_tools = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-swagger-tools && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_swagger_tools */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_swagger_tools\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_swagger_tools.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_swagger_tools.rollup.js'] =\n            local.assetsDict['/assets.npmtest_swagger_tools.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_swagger_tools.__dirname + '/lib.npmtest_swagger_tools.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/index.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar _ = require('lodash-compat');\nvar debug = require('debug')('swagger-tools:middleware');\nvar helpers = require('./lib/helpers');\n\nvar initializeMiddleware = function initializeMiddleware (rlOrSO, resources, callback) {\n  var args;\n  var spec;\n\n  debug('Initializing middleware');\n\n  if (_.isUndefined(rlOrSO)) {\n    throw new Error('rlOrSO is required');\n  } else if (!_.isPlainObject(rlOrSO)) {\n    throw new TypeError('rlOrSO must be an object');\n  }\n\n  args = [rlOrSO];\n  spec = helpers.getSpec(helpers.getSwaggerVersion(rlOrSO), true);\n\n  debug('  Identified Swagger version: %s', spec.version);\n\n  if (spec.version === '1.2') {\n    if (_.isUndefined(resources)) {\n      throw new Error('resources is required');\n    } else if (!_.isArray(resources)) {\n      throw new TypeError('resources must be an array');\n    }\n\n    debug('  Number of API Declarations: %d', resources.length);\n\n    args.push(resources);\n  } else {\n    callback = arguments[1];\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  args.push(function (err, results) {\n    if (results && results.errors.length + _.reduce(results.apiDeclarations || [], function (count, apiDeclaration) {\n      return count += (apiDeclaration ? apiDeclaration.errors.length : 0);\n    }, 0) > 0) {\n      err = new Error('Swagger document(s) failed validation so the server cannot start');\n\n      err.failedValidation = true;\n      err.results = results;\n    }\n\n    debug('  Validation: %s', err ? 'failed' : 'succeeded');\n\n    try {\n      if (err) {\n        throw err;\n      }\n\n      callback({\n        // Create a wrapper to avoid having to pass the non-optional arguments back to the swaggerMetadata middleware\n        swaggerMetadata: function () {\n          var swaggerMetadata = require('./middleware/swagger-metadata');\n\n          return swaggerMetadata.apply(undefined, args.slice(0, args.length - 1));\n        },\n        swaggerRouter: require('./middleware/swagger-router'),\n        swaggerSecurity: require('./middleware/swagger-security'),\n        // Create a wrapper to avoid having to pass the non-optional arguments back to the swaggerUi middleware\n        swaggerUi: function (options) {\n          var swaggerUi = require('./middleware/swagger-ui');\n          var suArgs = [rlOrSO];\n\n          if (spec.version === '1.2') {\n            suArgs.push(_.reduce(resources, function (map, resource) {\n              map[resource.resourcePath] = resource;\n\n              return map;\n            }, {}));\n          }\n\n          suArgs.push(options || {});\n\n          return swaggerUi.apply(undefined, suArgs);\n        },\n        swaggerValidator: require('./middleware/swagger-validator')\n      });\n    } catch (err) {\n      if (process.env.RUNNING_SWAGGER_TOOLS_TESTS === 'true') {\n        // When running the swagger-tools test suite, we want to return an error instead of exiting the process.  This\n        // does not mean that this function is an error-first callback but due to json-refs using Promises, we have to\n        // return the error to avoid the error being swallowed.\n        callback(err);\n      } else {\n        if (err.failedValidation === true) {\n          helpers.printValidationResults(spec.version, rlOrSO, resources, results, true);\n        } else {\n          console.error('Error initializing middleware');\n          console.error(err.stack);\n        }\n\n        process.exit(1);\n      }\n    }\n  });\n\n  spec.validate.apply(spec, args);\n};\n\nmodule.exports = {\n  initializeMiddleware: initializeMiddleware,\n  specs: require('./lib/specs')\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/lib/helpers.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n// Done this way to make the Browserify build smaller\nvar _ = {\n  each: require('lodash-compat/collection/each'),\n  indexOf: require('lodash-compat/array/indexOf'),\n  isArray: require('lodash-compat/lang/isArray'),\n  isPlainObject: require('lodash-compat/lang/isPlainObject'),\n  isString: require('lodash-compat/lang/isString'),\n  isUndefined: require('lodash-compat/lang/isUndefined'),\n  reduce: require('lodash-compat/collection/reduce')\n};\nvar JsonRefs = require('json-refs');\nvar traverse = require('traverse');\nvar ZSchema = require('z-schema');\n\nvar customJsonSchemaFormats = ['byte', 'double', 'float', 'int32', 'int64', 'mime-type', 'uri-template'];\nvar draft04Json = require('../schemas/json-schema-draft-04.json');\nvar draft04Url = 'http://json-schema.org/draft-04/schema';\nvar specCache = {};\n\nmodule.exports.registerCustomFormats = function (json) {\n  traverse(json).forEach(function () {\n    var name = this.key;\n    var format = this.node;\n\n    if (name === 'format' && _.indexOf(ZSchema.getRegisteredFormats(), format) === -1) {\n      ZSchema.registerFormat(format, function () {\n        return true;\n      });\n    }\n  });\n};\n\nmodule.exports.createJsonValidator = function (schemas) {\n  var validator = new ZSchema({\n    breakOnFirstError: false,\n    reportPathAsArray: true\n  });\n  var result;\n\n  // Add the draft-04 spec\n  validator.setRemoteReference(draft04Url, draft04Json);\n\n  // Swagger uses some unsupported/invalid formats so just make them all pass\n  _.each(customJsonSchemaFormats, function (format) {\n    ZSchema.registerFormat(format, function () {\n      return true;\n    });\n  });\n\n  // Compile and validate the schemas\n  if (!_.isUndefined(schemas)) {\n    result = validator.compileSchema(schemas);\n\n    // If there is an error, it's unrecoverable so just blow the eff up\n    if (result === false) {\n      console.error('JSON Schema file' + (schemas.length > 1 ? 's are' : ' is') + ' invalid:');\n\n      _.each(validator.getLastErrors(), function (err) {\n        console.error('  ' + (_.isArray(err.path) ? JsonRefs.pathToPtr(err.path) : err.path) + ': ' + err.message);\n      });\n\n      throw new Error('Unable to create validator due to invalid JSON Schema');\n    }\n  }\n\n  return validator;\n};\n\nmodule.exports.formatResults = function (results) {\n  if (results) {\n    // Update the results based on its content to indicate success/failure accordingly\n    results = (results.errors.length + results.warnings.length +\n    _.reduce(results.apiDeclarations, function (count, aResult) {\n      if (aResult) {\n        count += aResult.errors.length + aResult.warnings.length;\n      }\n\n      return count;\n    }, 0) > 0) ? results : undefined;\n  }\n\n  return results;\n};\n\nvar getErrorCount = module.exports.getErrorCount = function (results) {\n  var errors = 0;\n\n  if (results) {\n    errors = results.errors.length;\n\n    _.each(results.apiDeclarations, function (adResults) {\n      if (adResults) {\n        errors += adResults.errors.length;\n      }\n    });\n  }\n\n  return errors;\n};\n\nvar coerceVersion = function (version) {\n  // Convert the version to a number (Required for helpers.getSpec)\n  if (version && !_.isString(version)) {\n    version = version.toString();\n\n    // Handle rounding issues (Only required for when Swagger version ends in '.0')\n    if (version.indexOf('.') === -1) {\n      version += '.0';\n    }\n  }\n\n  return version;\n};\n\n/**\n * Returns the proper specification based on the human readable version.\n *\n * @param {string} version - The human readable Swagger version (Ex: 1.2)\n * @param {[boolean=false]} throwError - Throw an error if the version could not be identified\n *\n * @returns the corresponding Swagger Specification object or undefined if there is none\n */\nmodule.exports.getSpec = function (version, throwError) {\n  var spec;\n\n  version = coerceVersion(version);\n  spec = specCache[version];\n\n  if (_.isUndefined(spec)) {\n    switch (version) {\n    case '1.2':\n      spec = require('../lib/specs').v1_2; // jshint ignore:line\n\n      break;\n\n    case '2.0':\n      spec = require('../lib/specs').v2_0; // jshint ignore:line\n\n      break;\n\n    default:\n      if (throwError === true) {\n        throw new Error('Unsupported Swagger version: ' + version);\n      }\n    }\n  }\n\n  return spec;\n};\n\n/**\n * Atempts to figure out the Swagger version from the Swagger document.\n *\n * @param {object} document - The Swagger document\n *\n * @returns the Swagger version or undefined if the document is not a Swagger document\n */\nmodule.exports.getSwaggerVersion = function (document) {\n  return _.isPlainObject(document) ? coerceVersion(document.swaggerVersion || document.swagger) : undefined;\n};\n\nmodule.exports.printValidationResults = function (version, apiDOrSO, apiDeclarations, results, printSummary) {\n  var hasErrors = getErrorCount(results) > 0;\n  var stream = hasErrors ? console.error : console.log;\n  var pluralize = function (string, count) {\n    return count === 1 ? string : string + 's';\n  };\n  var printErrorsOrWarnings = function (header, entries, indent) {\n    if (header) {\n      stream(header + ':');\n      stream();\n    }\n\n    _.each(entries, function (entry) {\n      stream(new Array(indent + 1).join(' ') + JsonRefs.pathToPtr(entry.path) + ': ' + entry.message);\n\n      if (entry.inner) {\n        printErrorsOrWarnings (undefined, entry.inner, indent + 2);\n      }\n    });\n\n    if (header) {\n      stream();\n    }\n  };\n  var errorCount = 0;\n  var warningCount = 0;\n\n  stream();\n\n  if (results.errors.length > 0) {\n    errorCount += results.errors.length;\n\n    printErrorsOrWarnings('API Errors', results.errors, 2);\n  }\n\n  if (results.warnings.length > 0) {\n    warningCount += results.warnings.length;\n\n    printErrorsOrWarnings('API Warnings', results.warnings, 2);\n  }\n\n  if (results.apiDeclarations) {\n    results.apiDeclarations.forEach(function (adResult, index) {\n      if (!adResult) {\n        return;\n      }\n\n      var name = apiDeclarations[index].resourcePath || index;\n\n      if (adResult.errors.length > 0) {\n        errorCount += adResult.errors.length;\n\n        printErrorsOrWarnings('  API Declaration (' + name + ') Errors', adResult.errors, 4);\n      }\n\n      if (adResult.warnings.length > 0) {\n        warningCount += adResult.warnings.length;\n\n        printErrorsOrWarnings('  API Declaration (' + name + ') Warnings', adResult.warnings, 4);\n      }\n    });\n  }\n\n  if (printSummary) {\n    if (errorCount > 0) {\n      stream(errorCount + ' ' + pluralize('error', errorCount) + ' and ' + warningCount + ' ' +\n                    pluralize('warning', warningCount));\n    } else {\n      stream('Validation succeeded but with ' + warningCount + ' ' + pluralize('warning', warningCount));\n    }\n  }\n\n  stream();\n};\n\nmodule.exports.swaggerOperationMethods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'OPTIONS',\n  'PATCH',\n  'POST',\n  'PUT'\n];\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/lib/specs.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n// Done this way to make the Browserify build smaller\nvar _ = {\n  cloneDeep: require('lodash-compat/lang/cloneDeep'),\n  difference: require('lodash-compat/array/difference'),\n  each: require('lodash-compat/collection/each'),\n  find: require('lodash-compat/collection/find'),\n  has: require('lodash-compat/object/has'),\n  isArray: require('lodash-compat/lang/isArray'),\n  isFunction: require('lodash-compat/lang/isFunction'),\n  isPlainObject: require('lodash-compat/lang/isPlainObject'),\n  isString: require('lodash-compat/lang/isString'),\n  isUndefined: require('lodash-compat/lang/isUndefined'),\n  map: require('lodash-compat/collection/map'),\n  reduce: require('lodash-compat/collection/reduce'),\n  set: require('lodash-compat/object/set'),\n  union: require('lodash-compat/array/union')\n};\nvar async = require('async');\nvar helpers = require('./helpers');\nvar JsonRefs = require('json-refs');\nvar SparkMD5 = require('spark-md5');\nvar swaggerConverter = require('swagger-converter');\nvar traverse = require('traverse');\nvar validators = require('./validators');\nvar YAML = require('js-yaml');\n\n// Work around swagger-converter packaging issue (Browser builds only)\nif (_.isPlainObject(swaggerConverter)) {\n  swaggerConverter = global.SwaggerConverter.convert;\n}\n\nvar documentCache = {};\n\nvar sanitizeRef = function (version, ref) {\n  return version !== '1.2' ? ref : ref.replace('#/models/', '');\n};\n\nvar swagger1RefPreProcesor = function (obj) {\n  var pObj = _.cloneDeep(obj);\n\n  pObj.$ref = '#/models/' + obj.$ref;\n\n  return pObj;\n};\nvar validOptionNames = _.map(helpers.swaggerOperationMethods, function (method) {\n  return method.toLowerCase();\n});\n\nvar isRemotePtr = function (refDetails) {\n  return ['relative', 'remote'].indexOf(refDetails.type) > -1;\n};\n\nvar createErrorOrWarning = function (code, message, path, dest) {\n  dest.push({\n    code: code,\n    message: message,\n    path: path\n  });\n};\n\nvar addReference = function (cacheEntry, defPathOrPtr, refPathOrPtr, results, omitError) {\n  var result = true;\n  var swaggerVersion = helpers.getSwaggerVersion(cacheEntry.resolved);\n  var defPath = _.isArray(defPathOrPtr) ? defPathOrPtr : JsonRefs.pathFromPtr(defPathOrPtr);\n  var defPtr = _.isArray(defPathOrPtr) ? JsonRefs.pathToPtr(defPathOrPtr) : defPathOrPtr;\n  var refPath = _.isArray(refPathOrPtr) ? refPathOrPtr : JsonRefs.pathFromPtr(refPathOrPtr);\n  var refPtr = _.isArray(refPathOrPtr) ? JsonRefs.pathToPtr(refPathOrPtr) : refPathOrPtr;\n  var code;\n  var def;\n  var displayId;\n  var i;\n  var msgPrefix;\n  var type;\n\n  def = cacheEntry.definitions[defPtr];\n  type = defPath[0];\n  code = type === 'securityDefinitions' ?\n    'SECURITY_DEFINITION' :\n    type.substring(0, type.length - 1).toUpperCase();\n  displayId = swaggerVersion === '1.2' ? defPath[defPath.length - 1] : defPtr;\n  msgPrefix = type === 'securityDefinitions' ?\n    'Security definition' :\n    code.charAt(0) + code.substring(1).toLowerCase();\n\n  // This is an authorization scope reference\n  if (['authorizations', 'securityDefinitions'].indexOf(defPath[0]) > -1 && defPath[2] === 'scopes') {\n    code += '_SCOPE';\n    msgPrefix += ' scope';\n  }\n\n  // If the reference was not found and this is not an authorization/security scope reference, attempt to find a\n  // parent object to add the reference too.  (Issue 176)\n  if (_.isUndefined(def) && ['AUTHORIZATION_SCOPE', 'SECURITY_DEFINITION_SCOPE'].indexOf(code) === -1) {\n    // Attempt to find the definition in case the reference is to a path within a definition`\n    for (i = 1; i < defPath.length; i++) {\n      var pPath = defPath.slice(0, defPath.length - i);\n      var pPtr = JsonRefs.pathToPtr(pPath);\n      var pDef = cacheEntry.definitions[pPtr];\n\n      if (!_.isUndefined(pDef)) {\n        def = pDef;\n\n        break;\n      }\n    }\n  }\n\n  if (_.isUndefined(def)) {\n    if (!omitError) {\n      if (cacheEntry.swaggerVersion !== '1.2' && ['SECURITY_DEFINITION', 'SECURITY_DEFINITION_SCOPE'].indexOf(code) === -1) {\n        refPath.push('$ref');\n      }\n\n      createErrorOrWarning('UNRESOLVABLE_' + code, msgPrefix + ' could not be resolved: ' + displayId, refPath,\n                           results.errors);\n    }\n\n    result = false;\n  } else {\n    if (_.isUndefined(def.references)) {\n      def.references = [];\n    }\n\n    def.references.push(refPtr);\n  }\n\n  return result;\n};\n\nvar getOrComposeSchema = function (documentMetadata, modelId) {\n  var title = 'Composed ' + (documentMetadata.swaggerVersion === '1.2' ?\n                               JsonRefs.pathFromPtr(modelId).pop() :\n                               modelId);\n  var metadata = documentMetadata.definitions[modelId];\n  var originalT = traverse(documentMetadata.original);\n  var resolvedT = traverse(documentMetadata.resolved);\n  var composed;\n  var original;\n\n  if (!metadata) {\n    return undefined;\n  }\n\n  original = _.cloneDeep(originalT.get(JsonRefs.pathFromPtr(modelId)));\n  composed = _.cloneDeep(resolvedT.get(JsonRefs.pathFromPtr(modelId)));\n\n  // Convert the Swagger 1.2 document to a valid JSON Schema file\n  if (documentMetadata.swaggerVersion === '1.2') {\n    // Create inheritance model\n    if (metadata.lineage.length > 0) {\n      composed.allOf = [];\n\n      _.each(metadata.lineage, function (modelId) {\n        composed.allOf.push(getOrComposeSchema(documentMetadata, modelId));\n      });\n    }\n\n    // Remove the subTypes property\n    delete composed.subTypes;\n\n    _.each(composed.properties, function (property, name) {\n      var oProp = original.properties[name];\n\n      // Convert the string values to numerical values\n      _.each(['maximum', 'minimum'], function (prop) {\n        if (_.isString(property[prop])) {\n          property[prop] = parseFloat(property[prop]);\n        }\n      });\n\n      _.each(JsonRefs.findRefs(oProp, {\n        includeInvalid: true,\n        refPreProcessor: swagger1RefPreProcesor\n      }), function (refDetails, refPtr) {\n        var dMetadata = documentMetadata.definitions[refDetails.uri];\n        var path = JsonRefs.pathFromPtr(refPtr);\n\n        if (dMetadata.lineage.length > 0) {\n          traverse(property).set(path, getOrComposeSchema(documentMetadata, refDetails.uri));\n        } else {\n          traverse(property).set(path.concat('title'), 'Composed ' + sanitizeRef(documentMetadata.swaggerVersion,\n                                                                                 refDetails.uri));\n        }\n      });\n    });\n  }\n\n  // Scrub id properties\n  composed = traverse(composed).map(function (val) {\n    if (this.key === 'id' && _.isString(val)) {\n      this.remove();\n    }\n  });\n\n  composed.title = title;\n\n  return composed;\n};\n\nvar createUnusedErrorOrWarning = function (val, codeSuffix, msgPrefix, path, dest) {\n  createErrorOrWarning('UNUSED_' + codeSuffix, msgPrefix + ' is defined but is not used: ' + val, path, dest);\n};\n\nvar getDocumentCache = function (apiDOrSO) {\n  var key = SparkMD5.hash(JSON.stringify(apiDOrSO));\n  var cacheEntry = documentCache[key] || _.find(documentCache, function (cacheEntry) {\n    return cacheEntry.resolvedId === key;\n  });\n\n  if (!cacheEntry) {\n    cacheEntry = documentCache[key] = {\n      definitions: {},\n      original: apiDOrSO,\n      resolved: undefined,\n      swaggerVersion: helpers.getSwaggerVersion(apiDOrSO)\n    };\n  }\n\n  return cacheEntry;\n};\n\nvar handleValidationError = function (results, callback) {\n  var err = new Error('The Swagger document(s) are invalid');\n\n  err.errors = results.errors;\n  err.failedValidation = true;\n  err.warnings = results.warnings;\n\n  if (results.apiDeclarations) {\n    err.apiDeclarations = results.apiDeclarations;\n  }\n\n  callback(err);\n};\n\nvar normalizePath = function (path) {\n  var matches = path.match(/\\{(.*?)\\}/g);\n  var argNames = [];\n  var normPath = path;\n\n  if (matches) {\n    _.each(matches, function (match, index) {\n      normPath = normPath.replace(match, '{' + index + '}');\n      argNames.push(match.replace(/[{}]/g, ''));\n    });\n  }\n\n  return {\n    path: normPath,\n    args: argNames\n  };\n};\n\nvar removeCirculars = function (obj) {\n  function walk (ancestors, node, path) {\n    function walkItem (item, segment) {\n      path.push(segment);\n      walk(ancestors, item, path);\n      path.pop();\n    }\n\n    // We do not process circular objects again\n    if (ancestors.indexOf(node) === -1) {\n      ancestors.push(node);\n\n      if (_.isArray(node) || _.isPlainObject(node)) {\n        _.each(node, function (member, indexOrKey) {\n          walkItem(member, indexOrKey.toString());\n        });\n      }\n    } else {\n      _.set(obj, path, {});\n    }\n\n    ancestors.pop();\n  }\n\n  walk([], obj, []);\n};\n\n\nvar validateNoExist = function (data, val, codeSuffix, msgPrefix, path, dest) {\n  if (!_.isUndefined(data) && data.indexOf(val) > -1) {\n    createErrorOrWarning('DUPLICATE_' + codeSuffix, msgPrefix + ' already defined: ' + val, path, dest);\n  }\n};\n\nvar validateSchemaConstraints = function (documentMetadata, schema, path, results, skip) {\n  try {\n    validators.validateSchemaConstraints(documentMetadata.swaggerVersion, schema, path, undefined);\n  } catch (err) {\n    if (!skip) {\n      createErrorOrWarning(err.code, err.message, err.path, results.errors);\n    }\n  }\n};\n\nvar processDocument = function (documentMetadata, results) {\n  var swaggerVersion = documentMetadata.swaggerVersion;\n  var getDefinitionMetadata = function (defPath, inline) {\n    var defPtr = JsonRefs.pathToPtr(defPath);\n    var metadata = documentMetadata.definitions[defPtr];\n\n    if (!metadata) {\n      metadata = documentMetadata.definitions[defPtr] = {\n        inline: inline || false,\n        references: []\n      };\n\n      // For model definitions, add the inheritance properties\n      if (['definitions', 'models'].indexOf(JsonRefs.pathFromPtr(defPtr)[0]) > -1) {\n        metadata.cyclical = false;\n        metadata.lineage = undefined;\n        metadata.parents = [];\n      }\n    }\n\n    return metadata;\n  };\n  var getDisplayId = function (id) {\n    return swaggerVersion === '1.2' ? JsonRefs.pathFromPtr(id).pop() : id;\n  };\n  var jsonRefsOptions = {\n    filter: 'local',\n    includeInvalid: true\n  };\n  var walk = function (root, id, lineage) {\n    var definition = documentMetadata.definitions[id || root];\n\n    if (definition) {\n      _.each(definition.parents, function (parent) {\n        lineage.push(parent);\n\n        if (root !== parent) {\n          walk(root, parent, lineage);\n        }\n      });\n    }\n  };\n  var authDefsProp = swaggerVersion === '1.2' ? 'authorizations' : 'securityDefinitions';\n  var modelDefsProp = swaggerVersion === '1.2' ? 'models' : 'definitions';\n\n  // Process authorization definitions\n  _.each(documentMetadata.resolved[authDefsProp], function (authorization, name) {\n    var securityDefPath = [authDefsProp, name];\n\n    // Swagger 1.2 only has authorization definitions in the Resource Listing\n    if (swaggerVersion === '1.2' && !authorization.type) {\n      return;\n    }\n\n    // Create the authorization definition metadata\n    getDefinitionMetadata(securityDefPath);\n\n    _.reduce(authorization.scopes, function (seenScopes, scope, indexOrName) {\n      var scopeName = swaggerVersion === '1.2' ? scope.scope : indexOrName;\n      var scopeDefPath = securityDefPath.concat(['scopes', indexOrName.toString()]);\n      var scopeMetadata = getDefinitionMetadata(securityDefPath.concat(['scopes', scopeName]));\n\n      scopeMetadata.scopePath = scopeDefPath;\n\n      // Identify duplicate authorization scope defined in the Resource Listing\n      validateNoExist(seenScopes, scopeName, 'AUTHORIZATION_SCOPE_DEFINITION', 'Authorization scope definition',\n                      swaggerVersion === '1.2' ? scopeDefPath.concat('scope') : scopeDefPath, results.warnings);\n\n      seenScopes.push(scopeName);\n\n      return seenScopes;\n    }, []);\n  });\n\n  // Process model definitions\n  _.each(documentMetadata.resolved[modelDefsProp], function (model, modelId) {\n    var modelDefPath = [modelDefsProp, modelId];\n    var modelMetadata = getDefinitionMetadata(modelDefPath);\n\n    // Identify model id mismatch (Id in models object is not the same as the model's id in the models object)\n    if (swaggerVersion === '1.2' && modelId !== model.id) {\n      createErrorOrWarning('MODEL_ID_MISMATCH', 'Model id does not match id in models object: ' + model.id,\n                           modelDefPath.concat('id'), results.errors);\n    }\n\n    // Do not reprocess parents/references if already processed\n    if (_.isUndefined(modelMetadata.lineage)) {\n      // Handle inheritance references\n      switch (swaggerVersion) {\n      case '1.2':\n        _.each(model.subTypes, function (subType, index) {\n          var subPath = ['models', subType];\n          var subPtr = JsonRefs.pathToPtr(subPath);\n          var subMetadata = documentMetadata.definitions[subPtr];\n          var refPath = modelDefPath.concat(['subTypes', index.toString()]);\n\n          // If the metadata does not yet exist, create it\n          if (!subMetadata && documentMetadata.resolved[modelDefsProp][subType]) {\n            subMetadata = getDefinitionMetadata(subPath);\n          }\n\n          // If the reference is valid, add the parent\n          if (addReference(documentMetadata, subPath, refPath, results)) {\n            subMetadata.parents.push(JsonRefs.pathToPtr(modelDefPath));\n          }\n        });\n\n        break;\n\n      default:\n        _.each(documentMetadata.original[modelDefsProp][modelId].allOf, function (schema, index) {\n          var isInline = false;\n          var parentPath;\n\n          if (_.isUndefined(schema.$ref) || isRemotePtr(JsonRefs.getRefDetails(schema))) {\n            isInline = true;\n            parentPath = modelDefPath.concat(['allOf', index.toString()]);\n          } else {\n            parentPath = JsonRefs.pathFromPtr(schema.$ref);\n          }\n\n          // If the parent model does not exist, do not create its metadata\n          if (!_.isUndefined(traverse(documentMetadata.resolved).get(parentPath))) {\n            // Create metadata for parent\n            getDefinitionMetadata(parentPath, isInline);\n\n            modelMetadata.parents.push(JsonRefs.pathToPtr(parentPath));\n          }\n        });\n\n        break;\n      }\n    }\n  });\n\n  switch (swaggerVersion) {\n  case '2.0':\n    // Process parameter definitions\n    _.each(documentMetadata.resolved.parameters, function (parameter, name) {\n      var path = ['parameters', name];\n\n      getDefinitionMetadata(path);\n\n      validateSchemaConstraints(documentMetadata, parameter, path, results);\n    });\n\n    // Process response definitions\n    _.each(documentMetadata.resolved.responses, function (response, name) {\n      var path = ['responses', name];\n\n      getDefinitionMetadata(path);\n\n      validateSchemaConstraints(documentMetadata, response, path, results);\n    });\n\n    break;\n  }\n\n  // Validate definition/models (Inheritance, property definitions, ...)\n  _.each(documentMetadata.definitions, function (metadata, id) {\n    var defPath = JsonRefs.pathFromPtr(id);\n    var definition = traverse(documentMetadata.original).get(defPath);\n    var defProp = defPath[0];\n    var code = defProp.substring(0, defProp.length - 1).toUpperCase();\n    var msgPrefix = code.charAt(0) + code.substring(1).toLowerCase();\n    var dProperties;\n    var iProperties;\n    var lineage;\n\n    // The only checks we perform below are inheritance checks so skip all non-model definitions\n    if (['definitions', 'models'].indexOf(defProp) === -1) {\n      return;\n    }\n\n    dProperties = [];\n    iProperties = [];\n    lineage = metadata.lineage;\n\n    // Do not reprocess lineage if already processed\n    if (_.isUndefined(lineage)) {\n      lineage = [];\n\n      walk(id, undefined, lineage);\n\n      // Root > next > ...\n      lineage.reverse();\n\n      metadata.lineage = _.cloneDeep(lineage);\n\n      metadata.cyclical = lineage.length > 1 && lineage[0] === id;\n    }\n\n    // Swagger 1.2 does not allow multiple inheritance while Swagger 2.0+ does\n    if (metadata.parents.length > 1 && swaggerVersion === '1.2') {\n      createErrorOrWarning('MULTIPLE_' + code + '_INHERITANCE',\n                           'Child ' + code.toLowerCase() + ' is sub type of multiple models: ' +\n                           _.map(metadata.parents, function (parent) {\n                             return getDisplayId(parent);\n                           }).join(' && '), defPath, results.errors);\n    }\n\n    if (metadata.cyclical) {\n      createErrorOrWarning('CYCLICAL_' + code + '_INHERITANCE',\n                           msgPrefix + ' has a circular inheritance: ' +\n                             _.map(lineage, function (dep) {\n                               return getDisplayId(dep);\n                             }).join(' -> ') + ' -> ' + getDisplayId(id),\n                            defPath.concat(swaggerVersion === '1.2' ? 'subTypes' : 'allOf'), results.errors);\n    }\n\n    // Remove self reference from the end of the lineage (Front too if cyclical)\n    _.each(lineage.slice(metadata.cyclical ? 1 : 0), function (id) {\n      var pModel = traverse(documentMetadata.resolved).get(JsonRefs.pathFromPtr(id));\n\n      _.each(Object.keys(pModel.properties || {}), function (name) {\n        if (iProperties.indexOf(name) === -1) {\n          iProperties.push(name);\n        }\n      });\n    });\n\n    // Validate simple definitions\n    validateSchemaConstraints(documentMetadata, definition, defPath, results);\n\n    // Identify redeclared properties\n    _.each(definition.properties, function (property, name) {\n      var pPath = defPath.concat(['properties', name]);\n\n      // Do not process unresolved properties\n      if (!_.isUndefined(property)) {\n        validateSchemaConstraints(documentMetadata, property, pPath, results);\n\n        if (iProperties.indexOf(name) > -1) {\n          createErrorOrWarning('CHILD_' + code + '_REDECLARES_PROPERTY',\n                               'Child ' + code.toLowerCase() + ' declares property already declared by ancestor: ' +\n                               name,\n                               pPath, results.errors);\n        } else {\n          dProperties.push(name);\n        }\n      }\n    });\n\n    // Identify missing required properties\n    _.each(definition.required || [], function (name, index) {\n      var type = swaggerVersion === '1.2' ? 'Model' : 'Definition';\n\n      if (iProperties.indexOf(name) === -1 && dProperties.indexOf(name) === -1) {\n        createErrorOrWarning('MISSING_REQUIRED_' + type.toUpperCase() + '_PROPERTY',\n                             type + ' requires property but it is not defined: ' + name,\n                             defPath.concat(['required', index.toString()]), results.errors);\n      }\n    });\n  });\n\n  if (documentMetadata.swaggerVersion === '1.2') {\n    jsonRefsOptions.refPreProcessor = swagger1RefPreProcesor;\n  }\n\n  // Process local references\n  _.each(JsonRefs.findRefs(documentMetadata.original, jsonRefsOptions), function (refDetails, refPtr) {\n    addReference(documentMetadata, refDetails.uri, refPtr, results);\n  });\n\n  // Process invalid references\n  _.each(documentMetadata.referencesMetadata, function (refDetails, refPtr) {\n    if (isRemotePtr(refDetails) && refDetails.missing === true) {\n      results.errors.push({\n        code: 'UNRESOLVABLE_REFERENCE',\n        message: 'Reference could not be resolved: ' + sanitizeRef(documentMetadata.swaggerVersion, refDetails.uri),\n        path: JsonRefs.pathFromPtr(refPtr).concat('$ref')\n      });\n    }\n  });\n};\n\nvar validateExist = function (data, val, codeSuffix, msgPrefix, path, dest) {\n  if (!_.isUndefined(data) && data.indexOf(val) === -1) {\n    createErrorOrWarning('UNRESOLVABLE_' + codeSuffix, msgPrefix + ' could not be resolved: ' + val, path, dest);\n  }\n};\n\nvar processAuthRefs = function (documentMetadata, authRefs, path, results) {\n  var code = documentMetadata.swaggerVersion === '1.2' ? 'AUTHORIZATION' : 'SECURITY_DEFINITION';\n  var msgPrefix = code === 'AUTHORIZATION' ? 'Authorization' : 'Security definition';\n\n  if (documentMetadata.swaggerVersion === '1.2') {\n    _.reduce(authRefs, function (seenNames, scopes, name) {\n      var authPtr = ['authorizations', name];\n      var aPath = path.concat([name]);\n\n      // Add reference or record unresolved authorization\n      if (addReference(documentMetadata, authPtr, aPath, results)) {\n        _.reduce(scopes, function (seenScopes, scope, index) {\n          var sPath = aPath.concat(index.toString(), 'scope');\n          var sPtr = authPtr.concat(['scopes', scope.scope]);\n\n          validateNoExist(seenScopes, scope.scope, code + '_SCOPE_REFERENCE', msgPrefix + ' scope reference', sPath,\n                          results.warnings);\n\n          // Add reference or record unresolved authorization scope\n          addReference(documentMetadata, sPtr, sPath, results);\n\n          return seenScopes.concat(scope.scope);\n        }, []);\n      }\n\n      return seenNames.concat(name);\n    }, []);\n  } else {\n    _.reduce(authRefs, function (seenNames, scopes, index) {\n      _.each(scopes, function (scopes, name) {\n        var authPtr = ['securityDefinitions', name];\n        var authRefPath = path.concat(index.toString(), name);\n\n        // Ensure the security definition isn't referenced more than once (Swagger 2.0+)\n        validateNoExist(seenNames, name, code + '_REFERENCE', msgPrefix + ' reference', authRefPath,\n                        results.warnings);\n\n        seenNames.push(name);\n\n        // Add reference or record unresolved authorization\n        if (addReference(documentMetadata, authPtr, authRefPath, results)) {\n          _.each(scopes, function (scope, index) {\n            // Add reference or record unresolved authorization scope\n            var sPtr = authPtr.concat(['scopes', scope]);\n            addReference(documentMetadata, sPtr, authRefPath.concat(index.toString()),\n                         results);\n          });\n        }\n      });\n\n      return seenNames;\n    }, []);\n  }\n};\n\nvar resolveRefs = function (apiDOrSO, callback) {\n  var cacheEntry = getDocumentCache(apiDOrSO);\n  var swaggerVersion = helpers.getSwaggerVersion(apiDOrSO);\n  var jsonRefsOptions = {\n    includeInvalid: true,\n    loaderOptions: {\n      processContent: function (res, callback) {\n        callback(undefined, YAML.safeLoad(res.text));\n      }\n    }\n  };\n\n  if (!cacheEntry.resolved) {\n    // For Swagger 1.2, we have to create real JSON References\n    if (swaggerVersion === '1.2') {\n      jsonRefsOptions.refPreProcessor = swagger1RefPreProcesor;\n    }\n\n    // Resolve references\n    JsonRefs.resolveRefs(apiDOrSO, jsonRefsOptions)\n      .then(function (results) {\n        removeCirculars(results.resolved);\n\n        // Fix circular references\n        _.each(results.refs, function (refDetails, refPtr) {\n          if (refDetails.circular) {\n            _.set(results.resolved, JsonRefs.pathFromPtr(refPtr), {});\n          }\n        });\n\n        cacheEntry.referencesMetadata = results.refs;\n        cacheEntry.resolved = results.resolved;\n        cacheEntry.resolvedId = SparkMD5.hash(JSON.stringify(results.resolved));\n\n        callback();\n      })\n      .catch(callback);\n  } else {\n    callback();\n  }\n};\n\nvar validateAgainstSchema = function (spec, schemaOrName, data, callback) {\n  var validator = _.isString(schemaOrName) ? spec.validators[schemaOrName] : helpers.createJsonValidator();\n\n  helpers.registerCustomFormats(data);\n\n  try {\n    validators.validateAgainstSchema(schemaOrName, data, validator);\n  } catch (err) {\n    if (err.failedValidation) {\n      return callback(undefined, err.results);\n    } else {\n      return callback(err);\n    }\n  }\n\n  resolveRefs(data, function (err) {\n    return callback(err);\n  });\n};\n\nvar validateDefinitions = function (documentMetadata, results) {\n  // Validate unused definitions\n  _.each(documentMetadata.definitions, function (metadata, id) {\n    var defPath = JsonRefs.pathFromPtr(id);\n    var defType = defPath[0].substring(0, defPath[0].length - 1);\n    var displayId = documentMetadata.swaggerVersion === '1.2' ? defPath[defPath.length - 1] : id;\n    var code = defType === 'securityDefinition' ? 'SECURITY_DEFINITION' : defType.toUpperCase();\n    var msgPrefix = defType === 'securityDefinition' ?\n                             'Security definition' :\n                             defType.charAt(0).toUpperCase() + defType.substring(1);\n\n    if (metadata.references.length === 0 && !metadata.inline) {\n      // Swagger 1.2 authorization scope\n      if (metadata.scopePath) {\n        code += '_SCOPE';\n        msgPrefix += ' scope';\n        defPath = metadata.scopePath;\n      }\n\n      createUnusedErrorOrWarning(displayId, code, msgPrefix, defPath, results.warnings);\n    }\n  });\n};\n\nvar validateParameters = function (spec, documentMetadata, nPath, parameters, path, results,\n                                   skipMissing) {\n  var createParameterComboError = function (path) {\n    createErrorOrWarning('INVALID_PARAMETER_COMBINATION',\n                         'API cannot have a a body parameter and a ' +\n                           (spec.version === '1.2' ? 'form' : 'formData') + ' parameter',\n                         path, results.errors);\n  };\n  var pathParams = [];\n  var seenBodyParam = false;\n  var seenFormParam = false;\n\n  _.reduce(parameters, function (seenParameters, parameter, index) {\n    var pPath = path.concat(['parameters', index.toString()]);\n\n    // Unresolved parameter\n    if (_.isUndefined(parameter)) {\n      return;\n    }\n\n    // Identify duplicate parameter names\n    validateNoExist(seenParameters, parameter.name, 'PARAMETER', 'Parameter', pPath.concat('name'),\n                    results.errors);\n\n    // Keep track of body and path parameters\n    if (parameter.paramType === 'body' || parameter.in === 'body') {\n      if (seenBodyParam === true) {\n        createErrorOrWarning('DUPLICATE_API_BODY_PARAMETER', 'API has more than one body parameter', pPath,\n                             results.errors);\n      } else if (seenFormParam === true) {\n        createParameterComboError(pPath);\n      }\n\n      seenBodyParam = true;\n    } else if (parameter.paramType === 'form' || parameter.in === 'formData') {\n      if (seenBodyParam === true) {\n        createParameterComboError(pPath);\n      }\n\n      seenFormParam = true;\n    } else if (parameter.paramType === 'path' || parameter.in === 'path') {\n      if (nPath.args.indexOf(parameter.name) === -1) {\n        createErrorOrWarning('UNRESOLVABLE_API_PATH_PARAMETER',\n                             'API path parameter could not be resolved: ' + parameter.name, pPath.concat('name'),\n                             results.errors);\n      }\n\n      pathParams.push(parameter.name);\n    }\n\n    if (spec.primitives.indexOf(parameter.type) === -1 && spec.version === '1.2') {\n      addReference(documentMetadata, '#/models/' + parameter.type, pPath.concat('type'), results);\n    }\n\n    // Validate parameter constraints\n    validateSchemaConstraints(documentMetadata, parameter, pPath, results, parameter.skipErrors);\n\n    return seenParameters.concat(parameter.name);\n  }, []);\n\n  // Validate missing path parameters (in path but not in operation.parameters)\n  if (_.isUndefined(skipMissing) || skipMissing === false) {\n    _.each(_.difference(nPath.args, pathParams), function (unused) {\n      createErrorOrWarning('MISSING_API_PATH_PARAMETER', 'API requires path parameter but it is not defined: ' + unused,\n                           documentMetadata.swaggerVersion === '1.2' ? path.slice(0, 2).concat('path') : path,\n                           results.errors);\n    });\n  }\n};\n\nvar validateSwagger1_2 = function (spec, resourceListing, apiDeclarations, callback) { // jshint ignore:line\n  var adResourcePaths = [];\n  var rlDocumentMetadata = getDocumentCache(resourceListing);\n  var rlResourcePaths = [];\n  var results = {\n    errors: [],\n    warnings: [],\n    apiDeclarations: []\n  };\n\n  // Process Resource Listing resource definitions\n  rlResourcePaths = _.reduce(resourceListing.apis, function (seenPaths, api, index) {\n    // Identify duplicate resource paths defined in the Resource Listing\n    validateNoExist(seenPaths, api.path, 'RESOURCE_PATH', 'Resource path', ['apis', index.toString(), 'path'],\n                    results.errors);\n\n    seenPaths.push(api.path);\n\n    return seenPaths;\n  }, []);\n\n  // Process Resource Listing definitions (authorizations)\n  processDocument(rlDocumentMetadata, results);\n\n\n  // Process each API Declaration\n  adResourcePaths = _.reduce(apiDeclarations, function (seenResourcePaths, apiDeclaration, index) {\n    var aResults = results.apiDeclarations[index] = {\n      errors: [],\n      warnings: []\n    };\n    var adDocumentMetadata = getDocumentCache(apiDeclaration);\n\n    // Identify duplicate resource paths defined in the API Declarations\n    validateNoExist(seenResourcePaths, apiDeclaration.resourcePath, 'RESOURCE_PATH', 'Resource path',\n                    ['resourcePath'], aResults.errors);\n\n    if (adResourcePaths.indexOf(apiDeclaration.resourcePath) === -1) {\n      // Identify unused resource paths defined in the API Declarations\n      validateExist(rlResourcePaths, apiDeclaration.resourcePath, 'RESOURCE_PATH', 'Resource path',\n                    ['resourcePath'], aResults.errors);\n\n      seenResourcePaths.push(apiDeclaration.resourcePath);\n    }\n\n    // TODO: Process authorization references\n    // Not possible due to https://github.com/swagger-api/swagger-spec/issues/159\n\n    // Process models\n    processDocument(adDocumentMetadata, aResults);\n\n    // Process the API definitions\n    _.reduce(apiDeclaration.apis, function (seenPaths, api, index) {\n      var aPath = ['apis', index.toString()];\n      var nPath = normalizePath(api.path);\n\n      // Validate duplicate resource path\n      if (seenPaths.indexOf(nPath.path) > -1) {\n        createErrorOrWarning('DUPLICATE_API_PATH', 'API path (or equivalent) already defined: ' + api.path,\n                             aPath.concat('path'), aResults.errors);\n      } else {\n        seenPaths.push(nPath.path);\n      }\n\n      // Process the API operations\n      _.reduce(api.operations, function (seenMethods, operation, index) {\n        var oPath = aPath.concat(['operations', index.toString()]);\n\n        // Validate duplicate operation method\n        validateNoExist(seenMethods, operation.method, 'OPERATION_METHOD', 'Operation method', oPath.concat('method'),\n                        aResults.errors);\n\n        // Keep track of the seen methods\n        seenMethods.push(operation.method);\n\n        // Keep track of operation types\n        if (spec.primitives.indexOf(operation.type) === -1 && spec.version === '1.2') {\n          addReference(adDocumentMetadata, '#/models/' + operation.type, oPath.concat('type'), aResults);\n        }\n\n        // Process authorization references\n        processAuthRefs(rlDocumentMetadata, operation.authorizations, oPath.concat('authorizations'), aResults);\n\n        // Validate validate inline constraints\n        validateSchemaConstraints(adDocumentMetadata, operation, oPath, aResults);\n\n        // Validate parameters\n        validateParameters(spec, adDocumentMetadata, nPath, operation.parameters, oPath, aResults);\n\n        // Validate unique response code\n        _.reduce(operation.responseMessages, function (seenResponseCodes, responseMessage, index) {\n          var rmPath = oPath.concat(['responseMessages', index.toString()]);\n\n          validateNoExist(seenResponseCodes, responseMessage.code, 'RESPONSE_MESSAGE_CODE', 'Response message code',\n                          rmPath.concat(['code']), aResults.errors);\n\n          // Validate missing model\n          if (responseMessage.responseModel) {\n            addReference(adDocumentMetadata, '#/models/' + responseMessage.responseModel,\n                         rmPath.concat('responseModel'), aResults);\n          }\n\n          return seenResponseCodes.concat(responseMessage.code);\n        }, []);\n\n        return seenMethods;\n      }, []);\n\n      return seenPaths;\n    }, []);\n\n    // Validate API Declaration definitions\n    validateDefinitions(adDocumentMetadata, aResults);\n\n    return seenResourcePaths;\n  }, []);\n\n  // Validate API Declaration definitions\n  validateDefinitions(rlDocumentMetadata, results);\n\n  // Identify unused resource paths defined in the Resource Listing\n  _.each(_.difference(rlResourcePaths, adResourcePaths), function (unused) {\n    var index = rlResourcePaths.indexOf(unused);\n\n    createUnusedErrorOrWarning(resourceListing.apis[index].path, 'RESOURCE_PATH', 'Resource path',\n                               ['apis', index.toString(), 'path'], results.errors);\n  });\n\n  callback(undefined, results);\n};\n\nvar validateSwagger2_0 = function (spec, swaggerObject, callback) { // jshint ignore:line\n  var documentMetadata = getDocumentCache(swaggerObject);\n  var results = {\n    errors: [],\n    warnings: []\n  };\n\n  // Process definitions\n  processDocument(documentMetadata, results);\n\n  // Process security references\n  processAuthRefs(documentMetadata, swaggerObject.security, ['security'], results);\n\n  _.reduce(documentMetadata.resolved.paths, function (seenPaths, path, name) {\n    var pPath = ['paths', name];\n    var nPath = normalizePath(name);\n\n    // Validate duplicate resource path\n    if (seenPaths.indexOf(nPath.path) > -1) {\n      createErrorOrWarning('DUPLICATE_API_PATH', 'API path (or equivalent) already defined: ' + name, pPath,\n                           results.errors);\n    }\n\n    // Validate parameters\n    validateParameters(spec, documentMetadata, nPath, path.parameters, pPath, results, true);\n\n    // Validate the Operations\n    _.each(path, function (operation, method) {\n      var cParams = [];\n      var oPath = pPath.concat(method);\n      var seenParams = [];\n\n      if (validOptionNames.indexOf(method) === -1) {\n        return;\n      }\n\n      // Process security references\n      processAuthRefs(documentMetadata, operation.security, oPath.concat('security'), results);\n\n      // Compose parameters from path global parameters and operation parameters\n      _.each(operation.parameters, function (parameter) {\n        // Can happen with invalid references\n        if (_.isUndefined(parameter)) {\n          return;\n        }\n\n        cParams.push(parameter);\n\n        seenParams.push(parameter.name + ':' + parameter.in);\n      });\n\n      _.each(path.parameters, function (parameter) {\n        var cloned = _.cloneDeep(parameter);\n\n        // The only errors that can occur here are schema constraint validation errors which are already reported above\n        // so do not report them again.\n        cloned.skipErrors = true;\n\n        if (seenParams.indexOf(parameter.name + ':' + parameter.in) === -1) {\n          cParams.push(cloned);\n        }\n      });\n\n      // Validate parameters\n      validateParameters(spec, documentMetadata, nPath, cParams, oPath, results);\n\n      // Validate responses\n      _.each(operation.responses, function (response, responseCode) {\n        // Do not process references to missing responses\n        if (!_.isUndefined(response)) {\n          // Validate validate inline constraints\n          validateSchemaConstraints(documentMetadata, response, oPath.concat('responses', responseCode), results);\n        }\n      });\n    });\n\n    return seenPaths.concat(nPath.path);\n  }, []);\n\n  // Validate definitions\n  validateDefinitions(documentMetadata, results);\n\n  callback(undefined, results);\n};\n\nvar validateSemantically = function (spec, rlOrSO, apiDeclarations, callback) {\n  var cbWrapper = function (err, results) {\n    callback(err, helpers.formatResults(results));\n  };\n  if (spec.version === '1.2') {\n    validateSwagger1_2(spec, rlOrSO, apiDeclarations, cbWrapper); // jshint ignore:line\n  } else {\n    validateSwagger2_0(spec, rlOrSO, cbWrapper); // jshint ignore:line\n  }\n};\n\nvar validateStructurally = function (spec, rlOrSO, apiDeclarations, callback) {\n  validateAgainstSchema(spec, spec.version === '1.2' ? 'resourceListing.json' : 'schema.json', rlOrSO,\n                        function (err, results) {\n                          if (err) {\n                            return callback(err);\n                          }\n\n                          // Only validate the API Declarations if the API is 1.2 and the Resource Listing was valid\n                          if (!results && spec.version === '1.2') {\n                            results = {\n                              errors: [],\n                              warnings: [],\n                              apiDeclarations: []\n                            };\n\n                            async.map(apiDeclarations, function (apiDeclaration, callback2) {\n                              validateAgainstSchema(spec, 'apiDeclaration.json', apiDeclaration, callback2);\n                            }, function (err, allResults) {\n                              if (err) {\n                                return callback(err);\n                              }\n\n                              _.each(allResults, function (result, index) {\n                                results.apiDeclarations[index] = result;\n                              });\n\n                              callback(undefined, results);\n                            });\n                          } else {\n                            callback(undefined, results);\n                          }\n                        });\n};\n\n/**\n * Creates a new Swagger specification object.\n *\n * @param {string} version - The Swagger version\n *\n * @constructor\n */\nvar Specification = function (version) {\n  var that = this;\n  var createValidators = function (spec, validatorsMap) {\n    return _.reduce(validatorsMap, function (result, schemas, schemaName) {\n      result[schemaName] = helpers.createJsonValidator(schemas);\n\n      return result;\n    }, {});\n  };\n  var fixSchemaId = function (schemaName) {\n    // Swagger 1.2 schema files use one id but use a different id when referencing schema files.  We also use the schema\n    // file name to reference the schema in ZSchema.  To fix this so that the JSON Schema validator works properly, we\n    // need to set the id to be the name of the schema file.\n    var fixed = _.cloneDeep(that.schemas[schemaName]);\n\n    fixed.id = schemaName;\n\n    return fixed;\n  };\n  var primitives = ['string', 'number', 'boolean', 'integer', 'array'];\n\n  switch (version) {\n  case '1.2':\n    this.docsUrl = 'https://github.com/swagger-api/swagger-spec/blob/master/versions/1.2.md';\n    this.primitives = _.union(primitives, ['void', 'File']);\n    this.schemasUrl = 'https://github.com/swagger-api/swagger-spec/tree/master/schemas/v1.2';\n\n    // Here explicitly to allow browserify to work\n    this.schemas = {\n      'apiDeclaration.json': require('../schemas/1.2/apiDeclaration.json'),\n      'authorizationObject.json': require('../schemas/1.2/authorizationObject.json'),\n      'dataType.json': require('../schemas/1.2/dataType.json'),\n      'dataTypeBase.json': require('../schemas/1.2/dataTypeBase.json'),\n      'infoObject.json': require('../schemas/1.2/infoObject.json'),\n      'modelsObject.json': require('../schemas/1.2/modelsObject.json'),\n      'oauth2GrantType.json': require('../schemas/1.2/oauth2GrantType.json'),\n      'operationObject.json': require('../schemas/1.2/operationObject.json'),\n      'parameterObject.json': require('../schemas/1.2/parameterObject.json'),\n      'resourceListing.json': require('../schemas/1.2/resourceListing.json'),\n      'resourceObject.json': require('../schemas/1.2/resourceObject.json')\n    };\n\n    this.validators = createValidators(this, {\n      'apiDeclaration.json': _.map([\n        'dataTypeBase.json',\n        'modelsObject.json',\n        'oauth2GrantType.json',\n        'authorizationObject.json',\n        'parameterObject.json',\n        'operationObject.json',\n        'apiDeclaration.json'\n      ], fixSchemaId),\n      'resourceListing.json': _.map([\n        'resourceObject.json',\n        'infoObject.json',\n        'oauth2GrantType.json',\n        'authorizationObject.json',\n        'resourceListing.json'\n      ], fixSchemaId)\n    });\n\n    break;\n\n  case '2.0':\n    this.docsUrl = 'https://github.com/swagger-api/swagger-spec/blob/master/versions/2.0.md';\n    this.primitives = _.union(primitives, ['file']);\n    this.schemasUrl = 'https://github.com/swagger-api/swagger-spec/tree/master/schemas/v2.0';\n\n    // Here explicitly to allow browserify to work\n    this.schemas = {\n      'schema.json': require('../schemas/2.0/schema.json')\n    };\n\n    this.validators = createValidators(this, {\n      'schema.json': [fixSchemaId('schema.json')]\n    });\n\n    break;\n\n  default:\n    throw new Error(version + ' is an unsupported Swagger specification version');\n  }\n\n  this.version = version;\n};\n\n/**\n * Returns the result of the validation of the Swagger document(s).\n *\n * @param {object} rlOrSO - The Swagger Resource Listing (1.2) or Swagger Object (2.0)\n * @param {object[]} [apiDeclarations] - The array of Swagger API Declarations (1.2)\n * @param {resultCallback} callback - The result callback\n *\n * @returns undefined if validation passes or an object containing errors and/or warnings\n * @throws Error if the arguments provided are not valid\n */\nSpecification.prototype.validate = function (rlOrSO, apiDeclarations, callback) {\n  // Validate arguments\n  switch (this.version) {\n  case '1.2':\n    // Validate arguments\n    if (_.isUndefined(rlOrSO)) {\n      throw new Error('resourceListing is required');\n    } else if (!_.isPlainObject(rlOrSO)) {\n      throw new TypeError('resourceListing must be an object');\n    }\n\n    if (_.isUndefined(apiDeclarations)) {\n      throw new Error('apiDeclarations is required');\n    } else if (!_.isArray(apiDeclarations)) {\n      throw new TypeError('apiDeclarations must be an array');\n    }\n\n    break;\n\n  case '2.0':\n    // Validate arguments\n    if (_.isUndefined(rlOrSO)) {\n      throw new Error('swaggerObject is required');\n    } else if (!_.isPlainObject(rlOrSO)) {\n      throw new TypeError('swaggerObject must be an object');\n    }\n\n    break;\n  }\n\n  if (this.version === '2.0') {\n    callback = arguments[1];\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  // For Swagger 2.0, make sure apiDeclarations is an empty array\n  if (this.version === '2.0') {\n    apiDeclarations = [];\n  }\n\n  var that = this;\n\n  // Perform the validation\n  validateStructurally(this, rlOrSO, apiDeclarations, function (err, result) {\n    if (err || helpers.formatResults(result)) {\n      callback(err, result);\n    } else {\n      validateSemantically(that, rlOrSO, apiDeclarations, callback);\n    }\n  });\n};\n\n/**\n * Returns a JSON Schema representation of a composed model based on its id or reference.\n *\n * Note: For Swagger 1.2, we only perform structural validation prior to composing the model.\n *\n * @param {object} apiDOrSO - The Swagger Resource API Declaration (1.2) or the Swagger Object (2.0)\n * @param {string} modelIdOrRef - The model id (1.2) or the reference to the model (1.2 or 2.0)\n * @param {resultCallback} callback - The result callback\n *\n * @returns the object representing a composed object\n *\n * @throws Error if there are validation errors while creating\n */\nSpecification.prototype.composeModel = function (apiDOrSO, modelIdOrRef, callback) {\n  var swaggerVersion = helpers.getSwaggerVersion(apiDOrSO);\n  var doComposition = function (err, results) {\n    var documentMetadata;\n\n    if (err) {\n      return callback(err);\n    } else if (helpers.getErrorCount(results) > 0) {\n      return handleValidationError(results, callback);\n    }\n\n    documentMetadata = getDocumentCache(apiDOrSO);\n    results = {\n      errors: [],\n      warnings: []\n    };\n\n    processDocument(documentMetadata, results);\n\n    if (!documentMetadata.definitions[modelIdOrRef]) {\n      return callback();\n    }\n\n    if (helpers.getErrorCount(results) > 0) {\n      return handleValidationError(results, callback);\n    }\n\n    callback(undefined, getOrComposeSchema(documentMetadata, modelIdOrRef));\n  };\n\n  switch (this.version) {\n  case '1.2':\n    // Validate arguments\n    if (_.isUndefined(apiDOrSO)) {\n      throw new Error('apiDeclaration is required');\n    } else if (!_.isPlainObject(apiDOrSO)) {\n      throw new TypeError('apiDeclaration must be an object');\n    }\n\n    if (_.isUndefined(modelIdOrRef)) {\n      throw new Error('modelId is required');\n    }\n\n    break;\n\n  case '2.0':\n    // Validate arguments\n    if (_.isUndefined(apiDOrSO)) {\n      throw new Error('swaggerObject is required');\n    } else if (!_.isPlainObject(apiDOrSO)) {\n      throw new TypeError('swaggerObject must be an object');\n    }\n\n    if (_.isUndefined(modelIdOrRef)) {\n      throw new Error('modelRef is required');\n    }\n\n    break;\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  if (modelIdOrRef.charAt(0) !== '#') {\n    if (this.version === '1.2') {\n      modelIdOrRef = '#/models/' + modelIdOrRef;\n    } else {\n      throw new Error('modelRef must be a JSON Pointer');\n    }\n  }\n\n  // Ensure the document is valid first\n  if (swaggerVersion === '1.2') {\n    validateAgainstSchema(this, 'apiDeclaration.json', apiDOrSO, doComposition);\n  } else {\n    this.validate(apiDOrSO, doComposition);\n  }\n};\n\n/**\n * Validates a model based on its id.\n *\n * Note: For Swagger 1.2, we only perform structural validation prior to composing the model.\n *\n * @param {object} apiDOrSO - The Swagger Resource API Declaration (1.2) or the Swagger Object (2.0)\n * @param {string} modelIdOrRef - The model id (1.2) or the reference to the model (1.2 or 2.0)\n * @param {*} data - The model to validate\n * @param {resultCallback} callback - The result callback\n *\n * @returns undefined if validation passes or an object containing errors and/or warnings\n *\n * @throws Error if there are validation errors while creating\n */\nSpecification.prototype.validateModel = function (apiDOrSO, modelIdOrRef, data, callback) {\n  switch (this.version) {\n  case '1.2':\n    // Validate arguments\n    if (_.isUndefined(apiDOrSO)) {\n      throw new Error('apiDeclaration is required');\n    } else if (!_.isPlainObject(apiDOrSO)) {\n      throw new TypeError('apiDeclaration must be an object');\n    }\n\n    if (_.isUndefined(modelIdOrRef)) {\n      throw new Error('modelId is required');\n    }\n\n    break;\n\n  case '2.0':\n    // Validate arguments\n    if (_.isUndefined(apiDOrSO)) {\n      throw new Error('swaggerObject is required');\n    } else if (!_.isPlainObject(apiDOrSO)) {\n      throw new TypeError('swaggerObject must be an object');\n    }\n\n    if (_.isUndefined(modelIdOrRef)) {\n      throw new Error('modelRef is required');\n    }\n\n    break;\n  }\n\n  if (_.isUndefined(data)) {\n    throw new Error('data is required');\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  var that = this;\n\n  this.composeModel(apiDOrSO, modelIdOrRef, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n\n    validateAgainstSchema(that, result, data, callback);\n  });\n};\n\n/**\n * Returns a fully resolved document or document fragment.  (Does not perform validation as this is typically called\n * after validation occurs.))\n *\n * @param {object} document - The document to resolve or the document containing the reference to resolve\n * @param {string} [ptr] - The JSON Pointer or undefined to return the whole document\n * @param {resultCallback} callback - The result callback\n *\n * @returns the fully resolved document or fragment\n *\n * @throws Error if there are upstream errors\n */\nSpecification.prototype.resolve = function (document, ptr, callback) {\n  var documentMetadata;\n  var respond = function (document) {\n    if (_.isString(ptr)) {\n      return callback(undefined, traverse(document).get(JsonRefs.pathFromPtr(ptr)));\n    } else {\n      return callback(undefined, document);\n    }\n  };\n\n  // Validate arguments\n  if (_.isUndefined(document)) {\n    throw new Error('document is required');\n  } else if (!_.isPlainObject(document)) {\n    throw new TypeError('document must be an object');\n  }\n\n  if (arguments.length === 2) {\n    callback = arguments[1];\n    ptr = undefined;\n  }\n\n  if (!_.isUndefined(ptr) && !_.isString(ptr)) {\n    throw new TypeError('ptr must be a JSON Pointer string');\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  documentMetadata = getDocumentCache(document);\n\n  // Swagger 1.2 is not supported due to invalid JSON References being used.  Even if the JSON References were valid,\n  // the JSON Schema for Swagger 1.2 do not allow JavaScript objects in all places where the resoution would occur.\n  if (documentMetadata.swaggerVersion === '1.2') {\n    throw new Error('Swagger 1.2 is not supported');\n  }\n\n  if (!documentMetadata.resolved) {\n    // Ensure the document is valid first\n    this.validate(document, function (err, results) {\n      if (err) {\n        return callback(err);\n      } else if (helpers.getErrorCount(results) > 0) {\n        return handleValidationError(results, callback);\n      }\n\n      return respond(documentMetadata.resolved);\n    });\n  } else {\n    return respond(documentMetadata.resolved);\n  }\n};\n\n/**\n * Converts the Swagger 1.2 documents to a Swagger 2.0 document.\n *\n * @param {object} resourceListing - The Swagger Resource Listing\n * @param {object[]} [apiDeclarations] - The array of Swagger API Declarations\n * @param {boolean=false} [skipValidation] - Whether or not to skip validation\n * @param {resultCallback} callback - The result callback\n *\n * @returns the converted Swagger document\n *\n * @throws Error if the arguments provided are not valid\n */\nSpecification.prototype.convert = function (resourceListing, apiDeclarations, skipValidation, callback) {\n  var doConvert = function (resourceListing, apiDeclarations) {\n    callback(undefined, swaggerConverter(resourceListing, apiDeclarations));\n  };\n\n  if (this.version !== '1.2') {\n    throw new Error('Specification#convert only works for Swagger 1.2');\n  }\n\n  // Validate arguments\n  if (_.isUndefined(resourceListing)) {\n    throw new Error('resourceListing is required');\n  } else if (!_.isPlainObject(resourceListing)) {\n    throw new TypeError('resourceListing must be an object');\n  }\n\n  // API Declarations are optional because swagger-converter was written to support it\n  if (_.isUndefined(apiDeclarations)) {\n    apiDeclarations = [];\n  }\n\n  if (!_.isArray(apiDeclarations)) {\n    throw new TypeError('apiDeclarations must be an array');\n  }\n\n  if (arguments.length < 4) {\n    callback = arguments[arguments.length - 1];\n  }\n\n  if (_.isUndefined(callback)) {\n    throw new Error('callback is required');\n  } else if (!_.isFunction(callback)) {\n    throw new TypeError('callback must be a function');\n  }\n\n  if (skipValidation === true) {\n    doConvert(resourceListing, apiDeclarations);\n  } else {\n    this.validate(resourceListing, apiDeclarations, function (err, results) {\n      if (err) {\n        return callback(err);\n      } else if (helpers.getErrorCount(results) > 0) {\n        return handleValidationError(results, callback);\n      }\n\n      doConvert(resourceListing, apiDeclarations);\n    });\n  }\n};\n\nmodule.exports.v1 = module.exports.v1_2 = new Specification('1.2'); // jshint ignore:line\nmodule.exports.v2 = module.exports.v2_0 = new Specification('2.0'); // jshint ignore:line\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/lib/validators.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n// Done this way to make the Browserify build smaller\nvar _ = {\n  cloneDeep: require('lodash-compat/lang/cloneDeep'),\n  each: require('lodash-compat/collection/each'),\n  isArray: require('lodash-compat/lang/isArray'),\n  isBoolean: require('lodash-compat/lang/isBoolean'),\n  isDate: require('lodash-compat/lang/isDate'),\n  isFinite: require('lodash-compat/lang/isFinite'),\n  isNull: require('lodash-compat/lang/isNull'),\n  isNumber: require('lodash-compat/lang/isNumber'),\n  isPlainObject: require('lodash-compat/lang/isPlainObject'),\n  isString: require('lodash-compat/lang/isString'),\n  isUndefined: require('lodash-compat/lang/isUndefined'),\n  map: require('lodash-compat/collection/map'),\n  union: require('lodash-compat/array/union'),\n  uniq: require('lodash-compat/array/uniq')\n};\nvar helpers = require('./helpers');\n\n// http://tools.ietf.org/html/rfc3339#section-5.6\nvar dateRegExp = /^([0-9]{4})-([0-9]{2})-([0-9]{2})$/;\n// http://tools.ietf.org/html/rfc3339#section-5.6\nvar dateTimeRegExp = /^([0-9]{2}):([0-9]{2}):([0-9]{2})(.[0-9]+)?(z|([+-][0-9]{2}:[0-9]{2}))$/;\nvar isValidDate = function (date) {\n  var day;\n  var matches;\n  var month;\n\n  if (_.isDate(date)) {\n    return true;\n  }\n\n  if (!_.isString(date)) {\n    date = date.toString();\n  }\n\n  matches = dateRegExp.exec(date);\n\n  if (matches === null) {\n    return false;\n  }\n\n  day = matches[3];\n  month = matches[2];\n\n  if (month < '01' || month > '12' || day < '01' || day > '31') {\n    return false;\n  }\n\n  return true;\n};\nvar isValidDateTime = function (dateTime) {\n  var hour;\n  var date;\n  var time;\n  var matches;\n  var minute;\n  var parts;\n  var second;\n\n  if (_.isDate(dateTime)) {\n    return true;\n  }\n\n  if (!_.isString(dateTime)) {\n    dateTime = dateTime.toString();\n  }\n\n  parts = dateTime.toLowerCase().split('t');\n  date = parts[0];\n  time = parts.length > 1 ? parts[1] : undefined;\n\n  if (!isValidDate(date)) {\n    return false;\n  }\n\n  matches = dateTimeRegExp.exec(time);\n\n  if (matches === null) {\n    return false;\n  }\n\n  hour = matches[1];\n  minute = matches[2];\n  second = matches[3];\n\n  if (hour > '23' || minute > '59' || second > '59') {\n    return false;\n  }\n\n  return true;\n};\n\nvar throwErrorWithCode = function (code, msg) {\n  var err = new Error(msg);\n\n  err.code = code;\n  err.failedValidation = true;\n\n  throw err;\n};\n\nmodule.exports.validateAgainstSchema = function (schemaOrName, data, validator) {\n  var sanitizeError = function (obj) {\n    // Make anyOf/oneOf errors more human readable (Issue 200)\n    var defType = ['additionalProperties', 'items'].indexOf(obj.path[obj.path.length - 1]) > -1 ?\n          'schema' :\n          obj.path[obj.path.length - 2];\n\n    if (['ANY_OF_MISSING', 'ONE_OF_MISSING'].indexOf(obj.code) > -1) {\n      switch (defType) {\n      case 'parameters':\n        defType = 'parameter';\n        break;\n\n      case 'responses':\n        defType = 'response';\n        break;\n\n      case 'schema':\n        defType += ' ' + obj.path[obj.path.length - 1];\n\n        // no default\n      }\n\n      obj.message = 'Not a valid ' + defType + ' definition';\n    }\n\n    // Remove the params portion of the error\n    delete obj.params;\n    delete obj.schemaId;\n\n    if (obj.inner) {\n      _.each(obj.inner, function (nObj) {\n        sanitizeError(nObj);\n      });\n    }\n  };\n  var schema = _.isPlainObject(schemaOrName) ? _.cloneDeep(schemaOrName) : schemaOrName;\n\n  // We don't check this due to internal usage but if validator is not provided, schemaOrName must be a schema\n  if (_.isUndefined(validator)) {\n    validator = helpers.createJsonValidator([schema]);\n  }\n\n  var valid = validator.validate(data, schema);\n\n  if (!valid) {\n    try {\n      throwErrorWithCode('SCHEMA_VALIDATION_FAILED', 'Failed schema validation');\n    } catch (err) {\n      err.results = {\n        errors: _.map(validator.getLastErrors(), function (err) {\n          sanitizeError(err);\n\n          return err;\n        }),\n        warnings: []\n      };\n\n      throw err;\n    }\n  }\n};\n\n\n/**\n * Validates a schema of type array is properly formed (when necessar).\n *\n * *param {object} schema - The schema object to validate\n *\n * @throws Error if the schema says it's an array but it is not formed properly\n *\n * @see {@link https://github.com/swagger-api/swagger-spec/issues/174}\n */\nvar validateArrayType = module.exports.validateArrayType = function (schema) {\n  // We have to do this manually for now\n  if (schema.type === 'array' && _.isUndefined(schema.items)) {\n    throwErrorWithCode('OBJECT_MISSING_REQUIRED_PROPERTY', 'Missing required property: items');\n  }\n};\n\n/**\n * Validates the request or response content type (when necessary).\n *\n * @param {string[]} gPOrC - The valid consumes at the API scope\n * @param {string[]} oPOrC - The valid consumes at the operation scope\n * @param {object} reqOrRes - The request or response\n *\n * @throws Error if the content type is invalid\n */\nmodule.exports.validateContentType = function (gPOrC, oPOrC, reqOrRes) {\n  // http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2.1\n  var isResponse = typeof reqOrRes.end === 'function';\n  var contentType = isResponse ? reqOrRes.getHeader('content-type') : reqOrRes.headers['content-type'];\n  var pOrC = _.map(_.union(gPOrC, oPOrC), function (contentType) {\n    return contentType.split(';')[0];\n  });\n\n  if (!contentType) {\n    if (isResponse) {\n      contentType = 'text/plain';\n    } else {\n      contentType = 'application/octet-stream';\n    }\n  }\n\n  contentType = contentType.split(';')[0];\n\n  if (pOrC.length > 0 && (isResponse ?\n                          true :\n                          ['POST', 'PUT'].indexOf(reqOrRes.method) !== -1) && pOrC.indexOf(contentType) === -1) {\n    throw new Error('Invalid content type (' + contentType + ').  These are valid: ' + pOrC.join(', '));\n  }\n};\n\n/**\n * Validates the value against the allowable values (when necessary).\n *\n * @param {*} val - The parameter value\n * @param {string[]} allowed - The allowable values\n *\n * @throws Error if the value is not allowable\n */\nvar validateEnum = module.exports.validateEnum = function (val, allowed) {\n  if (!_.isUndefined(allowed) && !_.isUndefined(val) && allowed.indexOf(val) === -1) {\n    throwErrorWithCode('ENUM_MISMATCH', 'Not an allowable value (' + allowed.join(', ') + '): ' + val);\n  }\n};\n\n/**\n * Validates the value is less than the maximum (when necessary).\n *\n * @param {*} val - The parameter value\n * @param {string} maximum - The maximum value\n * @param {boolean} [exclusive=false] - Whether or not the value includes the maximum in its comparison\n *\n * @throws Error if the value is greater than the maximum\n */\nvar validateMaximum = module.exports.validateMaximum = function (val, maximum, type, exclusive) {\n  var code = exclusive === true ? 'MAXIMUM_EXCLUSIVE' : 'MAXIMUM';\n  var testMax;\n  var testVal;\n\n  if (_.isUndefined(exclusive)) {\n    exclusive = false;\n  }\n\n  if (type === 'integer') {\n    testVal = parseInt(val, 10);\n  } else if (type === 'number') {\n    testVal = parseFloat(val);\n  }\n\n  if (!_.isUndefined(maximum)) {\n    testMax = parseFloat(maximum);\n\n    if (exclusive && testVal >= testMax) {\n      throwErrorWithCode(code, 'Greater than or equal to the configured maximum (' + maximum + '): ' + val);\n    } else if (testVal > testMax) {\n      throwErrorWithCode(code, 'Greater than the configured maximum (' + maximum + '): ' + val);\n    }\n  }\n};\n\n/**\n * Validates the array count is less than the maximum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} maxItems - The maximum number of items\n *\n * @throws Error if the value contains more items than allowable\n */\nvar validateMaxItems = module.exports.validateMaxItems = function (val, maxItems) {\n  if (!_.isUndefined(maxItems) && val.length > maxItems) {\n    throwErrorWithCode('ARRAY_LENGTH_LONG', 'Array is too long (' + val.length + '), maximum ' + maxItems);\n  }\n};\n\n/**\n * Validates the value length is less than the maximum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} maxLength - The maximum length\n *\n * @throws Error if the value's length is greater than the maximum\n */\nvar validateMaxLength = module.exports.validateMaxLength = function (val, maxLength) {\n  if (!_.isUndefined(maxLength) && val.length > maxLength) {\n    throwErrorWithCode('MAX_LENGTH', 'String is too long (' + val.length + ' chars), maximum ' + maxLength);\n  }\n};\n\n/**\n * Validates the value's property count is greater than the maximum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} minProperties - The maximum number of properties\n *\n * @throws Error if the value's property count is less than the maximum\n */\nvar validateMaxProperties = module.exports.validateMaxProperties = function (val, maxProperties) {\n  var propCount = _.isPlainObject(val) ? Object.keys(val).length : 0;\n\n  if (!_.isUndefined(maxProperties) && propCount > maxProperties) {\n    throwErrorWithCode('MAX_PROPERTIES',\n                       'Number of properties is too many (' + propCount + ' properties), maximum ' + maxProperties);\n  }\n};\n\n/**\n * Validates the value array count is greater than the minimum (when necessary).\n *\n * @param {*} val - The parameter value\n * @param {string} minimum - The minimum value\n * @param {boolean} [exclusive=false] - Whether or not the value includes the minimum in its comparison\n *\n * @throws Error if the value is less than the minimum\n */\nvar validateMinimum = module.exports.validateMinimum = function (val, minimum, type, exclusive) {\n  var code = exclusive === true ? 'MINIMUM_EXCLUSIVE' : 'MINIMUM';\n  var testMin;\n  var testVal;\n\n  if (_.isUndefined(exclusive)) {\n    exclusive = false;\n  }\n\n  if (type === 'integer') {\n    testVal = parseInt(val, 10);\n  } else if (type === 'number') {\n    testVal = parseFloat(val);\n  }\n\n  if (!_.isUndefined(minimum)) {\n    testMin = parseFloat(minimum);\n\n    if (exclusive && testVal <= testMin) {\n      throwErrorWithCode(code, 'Less than or equal to the configured minimum (' + minimum + '): ' + val);\n    } else if (testVal < testMin) {\n      throwErrorWithCode(code, 'Less than the configured minimum (' + minimum + '): ' + val);\n    }\n  }\n};\n\n/**\n * Validates the value value contains fewer items than allowed (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} minItems - The minimum number of items\n *\n * @throws Error if the value contains fewer items than allowable\n */\nvar validateMinItems = module.exports.validateMinItems = function (val, minItems) {\n  if (!_.isUndefined(minItems) && val.length < minItems) {\n    throwErrorWithCode('ARRAY_LENGTH_SHORT', 'Array is too short (' + val.length + '), minimum ' + minItems);\n  }\n};\n\n/**\n * Validates the value length is less than the minimum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} minLength - The minimum length\n *\n * @throws Error if the value's length is less than the minimum\n */\nvar validateMinLength = module.exports.validateMinLength = function (val, minLength) {\n  if (!_.isUndefined(minLength) && val.length < minLength) {\n    throwErrorWithCode('MIN_LENGTH', 'String is too short (' + val.length + ' chars), minimum ' + minLength);\n  }\n};\n\n/**\n * Validates the value's property count is less than or equal to the minimum (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} minProperties - The minimum number of properties\n *\n * @throws Error if the value's property count is less than the minimum\n */\nvar validateMinProperties = module.exports.validateMinProperties = function (val, minProperties) {\n  var propCount = _.isPlainObject(val) ? Object.keys(val).length : 0;\n\n  if (!_.isUndefined(minProperties) && propCount < minProperties) {\n    throwErrorWithCode('MIN_PROPERTIES',\n                       'Number of properties is too few (' + propCount + ' properties), minimum ' + minProperties);\n  }\n};\n\n/**\n * Validates the value is a multiple of the provided number (when necessary).\n *\n * @param {*[]} val - The parameter value\n * @param {number} multipleOf - The number that should divide evenly into the value\n *\n * @throws Error if the value contains fewer items than allowable\n */\nvar validateMultipleOf = module.exports.validateMultipleOf = function (val, multipleOf) {\n  if (!_.isUndefined(multipleOf) && val % multipleOf !== 0) {\n    throwErrorWithCode('MULTIPLE_OF', 'Not a multiple of ' + multipleOf);\n  }\n};\n\n/**\n * Validates the value matches a pattern (when necessary).\n *\n * @param {string} name - The parameter name\n * @param {*} val - The parameter value\n * @param {string} pattern - The pattern\n *\n * @throws Error if the value does not match the pattern\n */\nvar validatePattern = module.exports.validatePattern = function (val, pattern) {\n  if (!_.isUndefined(pattern) && _.isNull(val.match(new RegExp(pattern)))) {\n    throwErrorWithCode('PATTERN', 'Does not match required pattern: ' + pattern);\n  }\n};\n\n/**\n * Validates the value requiredness (when necessary).\n *\n * @param {*} val - The parameter value\n * @param {boolean} required - Whether or not the parameter is required\n *\n * @throws Error if the value is required but is not present\n */\nmodule.exports.validateRequiredness = function (val, required) {\n  if (!_.isUndefined(required) && required === true && _.isUndefined(val)) {\n    throwErrorWithCode('REQUIRED', 'Is required');\n  }\n};\n\n/**\n * Validates the value type and format (when necessary).\n *\n * @param {string} version - The Swagger version\n * @param {*} val - The parameter value\n * @param {string} type - The parameter type\n * @param {string} format - The parameter format\n * @param {boolean} [skipError=false] - Whether or not to skip throwing an error (Useful for validating arrays)\n *\n * @throws Error if the value is not the proper type or format\n */\nvar validateTypeAndFormat = module.exports.validateTypeAndFormat =\n  function validateTypeAndFormat (version, val, type, format, allowEmptyValue, skipError) {\n    var result = true;\n    var oVal = val;\n\n    // If there is an empty value and we allow empty values, the value is always valid\n    if (allowEmptyValue === true && val === '') {\n      return;\n    }\n\n    if (_.isArray(val)) {\n      _.each(val, function (aVal, index) {\n        if (!validateTypeAndFormat(version, aVal, type, format, allowEmptyValue, true)) {\n          throwErrorWithCode('INVALID_TYPE', 'Value at index ' + index + ' is not a valid ' + type + ': ' + aVal);\n        }\n      });\n    } else {\n      switch (type) {\n      case 'boolean':\n        // Coerce the value only for Swagger 1.2\n        if (version === '1.2' && _.isString(val)) {\n          if (val === 'false') {\n            val = false;\n          } else if (val === 'true') {\n            val = true;\n          }\n        }\n\n        result = _.isBoolean(val);\n        break;\n      case 'integer':\n        // Coerce the value only for Swagger 1.2\n        if (version === '1.2' && _.isString(val)) {\n          val = Number(val);\n        }\n\n        result = _.isFinite(val) && (Math.round(val) === val);\n        break;\n      case 'number':\n        // Coerce the value only for Swagger 1.2\n        if (version === '1.2' && _.isString(val)) {\n          val = Number(val);\n        }\n\n        result = _.isFinite(val);\n        break;\n      case 'string':\n        if (!_.isUndefined(format)) {\n          switch (format) {\n          case 'date':\n            result = isValidDate(val);\n            break;\n          case 'date-time':\n            result = isValidDateTime(val);\n            break;\n          }\n        }\n        break;\n      case 'void':\n        result = _.isUndefined(val);\n        break;\n      }\n    }\n\n    if (skipError) {\n      return result;\n    } else if (!result) {\n      throwErrorWithCode('INVALID_TYPE',\n                         type !== 'void' ?\n                           'Not a valid ' + (_.isUndefined(format) ? '' : format + ' ') + type + ': ' + oVal :\n                           'Void does not allow a value');\n    }\n  };\n\n/**\n * Validates the value values are unique (when necessary).\n *\n * @param {string[]} val - The parameter value\n * @param {boolean} isUnique - Whether or not the parameter values are unique\n *\n * @throws Error if the value has duplicates\n */\nvar validateUniqueItems = module.exports.validateUniqueItems = function (val, isUnique) {\n  if (!_.isUndefined(isUnique) && _.uniq(val).length !== val.length) {\n    throwErrorWithCode('ARRAY_UNIQUE', 'Does not allow duplicate values: ' + val.join(', '));\n  }\n};\n\n/**\n * Validates the value against the schema.\n *\n * @param {string} version - The Swagger version\n * @param {object} schema - The schema to use to validate things\n * @param {string[]} path - The path to the schema\n * @param {*} [val] - The value to validate or undefined to use the default value provided by the schema\n *\n * @throws Error if any validation failes\n */\nvar validateSchemaConstraints = module.exports.validateSchemaConstraints = function (version, schema, path, val) {\n  var resolveSchema = function (schema) {\n    var resolved = schema;\n\n    if (resolved.schema) {\n      path = path.concat(['schema']);\n\n      resolved = resolveSchema(resolved.schema);\n    }\n\n    return resolved;\n  };\n\n  var type = schema.type;\n  var allowEmptyValue;\n\n  if (!type) {\n    if (!schema.schema) {\n      if (path[path.length - 2] === 'responses') {\n        type = 'void';\n      } else {\n        type = 'object';\n      }\n    } else {\n      schema = resolveSchema(schema);\n      type = schema.type || 'object';\n    }\n  }\n\n  allowEmptyValue = schema ? schema.allowEmptyValue === true : false;\n\n  try {\n    // Always perform this check even if there is no value\n    if (type === 'array') {\n      validateArrayType(schema);\n    }\n\n    // Default to default value if necessary\n    if (_.isUndefined(val)) {\n      val = version === '1.2' ? schema.defaultValue : schema.default;\n\n      path = path.concat([version === '1.2' ? 'defaultValue' : 'default']);\n    }\n\n    // If there is no explicit default value, return as all validations will fail\n    if (_.isUndefined(val)) {\n      return;\n    }\n\n    if (type === 'array') {\n      _.each(val, function (val, index) {\n        try {\n          validateSchemaConstraints(version, schema.items || {}, path.concat(index.toString()), val);\n        } catch (err) {\n          err.message = 'Value at index ' + index + ' ' + (err.code === 'INVALID_TYPE' ? 'is ' : '') +\n            err.message.charAt(0).toLowerCase() + err.message.substring(1);\n\n          throw err;\n        }\n      });\n    } else {\n      validateTypeAndFormat(version, val, type, schema.format, allowEmptyValue);\n    }\n\n    // Validate enum\n    validateEnum(val, schema.enum);\n\n    // Validate maximum\n    validateMaximum(val, schema.maximum, type, schema.exclusiveMaximum);\n\n\n    // Validate maxItems (Swagger 2.0+)\n    validateMaxItems(val, schema.maxItems);\n\n    // Validate maxLength (Swagger 2.0+)\n    validateMaxLength(val, schema.maxLength);\n\n    // Validate maxProperties (Swagger 2.0+)\n    validateMaxProperties(val, schema.maxProperties);\n\n    // Validate minimum\n    validateMinimum(val, schema.minimum, type, schema.exclusiveMinimum);\n\n    // Validate minItems\n    validateMinItems(val, schema.minItems);\n\n    // Validate minLength (Swagger 2.0+)\n    validateMinLength(val, schema.minLength);\n\n    // Validate minProperties (Swagger 2.0+)\n    validateMinProperties(val, schema.minProperties);\n\n    // Validate multipleOf (Swagger 2.0+)\n    validateMultipleOf(val, schema.multipleOf);\n\n    // Validate pattern (Swagger 2.0+)\n    validatePattern(val, schema.pattern);\n\n    // Validate uniqueItems\n    validateUniqueItems(val, schema.uniqueItems);\n  } catch (err) {\n    err.path = path;\n\n    throw err;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/middleware/swagger-metadata.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar _ = require('lodash-compat');\nvar async = require('async');\nvar bp = require('body-parser');\nvar cHelpers = require('../lib/helpers');\nvar debug = require('debug')('swagger-tools:middleware:metadata');\nvar mHelpers = require('./helpers');\nvar multer = require('multer');\nvar parseurl = require('parseurl');\nvar pathToRegexp = require('path-to-regexp');\n\n// Upstream middlewares\nvar bodyParserOptions = {\n  extended: false\n};\nvar multerOptions = {\n  storage: multer.memoryStorage()\n};\nvar textBodyParserOptions = {\n  type: '*/*'\n};\n\nvar jsonBodyParser = bp.json();\nvar parseQueryString = mHelpers.parseQueryString;\nvar queryParser = function (req, res, next) {\n  if (_.isUndefined(req.query)) {\n    req.query = parseQueryString(req);\n  }\n\n  return next();\n};\nvar realTextBodyParser = bp.text(textBodyParserOptions);\nvar textBodyParser = function (req, res, next) {\n  if (_.isUndefined(req.body)) {\n    realTextBodyParser(req, res, next);\n  } else {\n    next();\n  }\n};\nvar urlEncodedBodyParser = bp.urlencoded(bodyParserOptions);\nvar bodyParser = function (req, res, next) {\n  if (_.isUndefined(req.body)) {\n    urlEncodedBodyParser(req, res, function (err) {\n      if (err) {\n        next(err);\n      } else {\n        jsonBodyParser(req, res, next);\n      }\n    });\n  } else {\n    next();\n  }\n};\nvar realMultiPartParser = multer(multerOptions);\nvar makeMultiPartParser = function (parser) {\n  return function (req, res, next) {\n    if (_.isUndefined(req.files)) {\n      parser(req, res, next);\n    } else {\n      next();\n    }\n  };\n};\n\n// Helper functions\nvar expressStylePath = function (basePath, apiPath) {\n  basePath = parseurl({url: basePath || '/'}).pathname || '/';\n\n  // Make sure the base path starts with '/'\n  if (basePath.charAt(0) !== '/') {\n    basePath = '/' + basePath;\n  }\n\n  // Make sure the base path ends with '/'\n  if (basePath.charAt(basePath.length - 1) !== '/') {\n    basePath = basePath + '/';\n  }\n\n  // Make sure the api path does not start with '/' since the base path will end with '/'\n  if (apiPath.charAt(0) === '/') {\n    apiPath = apiPath.substring(1);\n  }\n\n  // Replace Swagger syntax for path parameters with Express' version (All Swagger path parameters are required)\n  return (basePath + apiPath).replace(/{/g, ':').replace(/}/g, '');\n};\n\nvar processOperationParameters = function (swaggerMetadata, pathKeys, pathMatch, req, res, next) {\n  var version = swaggerMetadata.swaggerVersion;\n  var spec = cHelpers.getSpec(cHelpers.getSwaggerVersion(version === '1.2' ?\n                                                         swaggerMetadata.resourceListing :\n                                                         swaggerMetadata.swaggerObject), true);\n  var parameters = !_.isUndefined(swaggerMetadata) ?\n                     (version === '1.2' ? swaggerMetadata.operation.parameters : swaggerMetadata.operationParameters) :\n                     undefined;\n\n  if (!parameters) {\n    return next();\n  }\n\n  debug('  Processing Parameters');\n\n  var parsers = _.reduce(parameters, function (requestParsers, parameter) {\n    var contentType = req.headers['content-type'];\n    var paramLocation = version === '1.2' ? parameter.paramType : parameter.schema.in;\n    var paramType = mHelpers.getParameterType(version === '1.2' ? parameter : parameter.schema);\n    var parsableBody = mHelpers.isModelType(spec, paramType) || ['array', 'object'].indexOf(paramType) > -1;\n    var parser;\n\n    switch (paramLocation) {\n      case 'body':\n      case 'form':\n      case 'formData':\n        if (paramType.toLowerCase() === 'file' || (contentType && contentType.split(';')[0] === 'multipart/form-data')) {\n          // Do not add a parser, multipart will be handled after\n          break;\n        } else if (paramLocation !== 'body' || parsableBody) {\n          parser = bodyParser;\n        } else {\n          parser = textBodyParser;\n        }\n\n        break;\n\n      case 'query':\n        parser = queryParser;\n\n        break;\n    }\n\n    if (parser && requestParsers.indexOf(parser) === -1) {\n      requestParsers.push(parser);\n    }\n\n    return requestParsers;\n  }, []);\n\n  // Multipart is handled by multer, which needs an array of {parameterName, maxCount}\n  var multiPartFields = _.reduce(parameters, function (fields, parameter) {\n    var paramLocation = version === '1.2' ? parameter.paramType : parameter.schema.in;\n    var paramType = mHelpers.getParameterType(version === '1.2' ? parameter : parameter.schema);\n    var paramName = version === '1.2' ? parameter.name : parameter.schema.name;\n\n    switch (paramLocation) {\n      case 'body':\n      case 'form':\n      case 'formData':\n        if (paramType.toLowerCase() === 'file') {\n          // Swagger spec does not allow array of files, so maxCount should be 1\n          fields.push({name: paramName, maxCount: 1});\n        }\n        break;\n    }\n\n    return fields;\n  }, []);\n  \n  var contentType = req.headers['content-type'];\n  if (multiPartFields.length) {\n    // If there are files, use multer#fields\n    parsers.push(makeMultiPartParser(realMultiPartParser.fields(multiPartFields)));\n  } else if (contentType && contentType.split(';')[0] === 'multipart/form-data') {\n    // If no files but multipart form, use empty multer#array for text fields\n    parsers.push(makeMultiPartParser(realMultiPartParser.array()));\n  }\n\n  async.map(parsers, function (parser, callback) {\n    parser(req, res, callback);\n  }, function (err) {\n    if (err) {\n      return next(err);\n    }\n\n    _.each(parameters, function (parameterOrMetadata, index) {\n      var parameter = version === '1.2' ? parameterOrMetadata : parameterOrMetadata.schema;\n      var pType = mHelpers.getParameterType(parameter);\n      var oVal;\n      var value;\n\n      debug('    %s', parameter.name);\n      debug('      Type: %s%s', pType, !_.isUndefined(parameter.format) ? ' (format: ' + parameter.format + ')': '');\n\n      // Located here to make the debug output pretty\n      oVal = mHelpers.getParameterValue(version, parameter, pathKeys, pathMatch, req, debug);\n      value = mHelpers.convertValue(oVal, _.isUndefined(parameter.schema) ? parameter : parameter.schema, pType);\n\n      debug('      Value: %s', value);\n\n      swaggerMetadata.params[parameter.name] = {\n        path: version === '1.2' ?\n                swaggerMetadata.operationPath.concat(['parameters', index.toString()]) :\n                parameterOrMetadata.path,\n        schema: parameter,\n        originalValue: oVal,\n        value: value\n      };\n    });\n\n    return next();\n  });\n};\nvar processSwaggerDocuments = function (rlOrSO, apiDeclarations) {\n  if (_.isUndefined(rlOrSO)) {\n    throw new Error('rlOrSO is required');\n  } else if (!_.isPlainObject(rlOrSO)) {\n    throw new TypeError('rlOrSO must be an object');\n  }\n\n  var spec = cHelpers.getSpec(cHelpers.getSwaggerVersion(rlOrSO), true);\n  var apiCache = {};\n  var composeParameters = function (apiPath, method, path, operation) {\n    var cParams = [];\n    var seenParams = [];\n\n    _.each(operation.parameters, function (parameter, index) {\n      cParams.push({\n        path: apiPath.concat([method, 'parameters', index.toString()]),\n        schema: parameter\n      });\n\n      seenParams.push(parameter.name + ':' + parameter.in);\n    });\n\n    _.each(path.parameters, function (parameter, index) {\n      if (seenParams.indexOf(parameter.name + ':' + parameter.in) === -1) {\n        cParams.push({\n          path: apiPath.concat(['parameters', index.toString()]),\n          schema: parameter\n        });\n      }\n    });\n\n    return cParams;\n  };\n  var createCacheEntry = function (adOrSO, apiOrPath, indexOrName, indent) {\n    var apiPath = spec.version === '1.2' ? apiOrPath.path : indexOrName;\n    var expressPath = expressStylePath(adOrSO.basePath, spec.version === '1.2' ? apiOrPath.path: indexOrName);\n    var keys = [];\n    var handleSubPaths = !(rlOrSO.paths && rlOrSO.paths[apiPath]['x-swagger-router-handle-subpaths']);\n    var re = pathToRegexp(expressPath, keys, { end: handleSubPaths });\n    var cacheKey = re.toString();\n    var cacheEntry;\n\n    // This is an absolute path, use it as the cache key\n    if (expressPath.indexOf('{') === -1) {\n      cacheKey = expressPath;\n    }\n\n    debug(new Array(indent + 1).join(' ') + 'Found %s: %s',\n          (spec.version === '1.2' ? 'API' : 'Path'),\n          apiPath);\n\n    cacheEntry = apiCache[cacheKey] = spec.version === '1.2' ?\n      {\n        api: apiOrPath,\n        apiDeclaration: adOrSO,\n        apiIndex: indexOrName,\n        keys: keys,\n        params: {},\n        re: re,\n        operations: {},\n        resourceListing: rlOrSO\n      } :\n      {\n        apiPath: indexOrName,\n        path: apiOrPath,\n        keys: keys,\n        re: re,\n        operations: {},\n        swaggerObject: {\n          original: rlOrSO,\n          resolved: adOrSO\n        }\n      };\n\n    return cacheEntry;\n  };\n\n  debug('  Identified Swagger version: %s', spec.version);\n\n  if (spec.version === '1.2') {\n    if (_.isUndefined(apiDeclarations)) {\n      throw new Error('apiDeclarations is required');\n    } else if (!_.isArray(apiDeclarations)) {\n      throw new TypeError('apiDeclarations must be an array');\n    }\n\n    debug('  Number of API Declarations: %d', apiDeclarations.length);\n\n    _.each(apiDeclarations, function (apiDeclaration, adIndex) {\n      debug('  Processing API Declaration %d', adIndex);\n\n      _.each(apiDeclaration.apis, function (api, apiIndex) {\n        var cacheEntry = createCacheEntry(apiDeclaration, api, apiIndex, 4);\n\n        cacheEntry.resourceIndex = adIndex;\n\n        _.each(api.operations, function (operation, operationIndex) {\n          cacheEntry.operations[operation.method.toLowerCase()] = {\n            operation: operation,\n            operationPath: ['apis', apiIndex.toString(), 'operations', operationIndex.toString()],\n            operationParameters: operation.parameters\n          };\n        });\n      });\n    });\n  } else {\n    // To avoid running into issues with references throughout the Swagger object we will use the resolved version.\n    // Getting the resolved version is an asynchronous process but since initializeMiddleware caches the resolved document\n    // this is a synchronous action at this point.\n    spec.resolve(rlOrSO, function (err, resolved) {\n      // Gather the paths, their path regex patterns and the corresponding operations\n      _.each(resolved.paths, function (path, pathName) {\n        var cacheEntry = createCacheEntry(resolved, path, pathName, 2);\n\n        _.each(['get', 'put', 'post', 'delete', 'options', 'head', 'patch'], function (method) {\n          var operation = path[method];\n\n          if (!_.isUndefined(operation)) {\n            cacheEntry.operations[method] = {\n              operation: operation,\n              operationPath: ['paths', pathName, method],\n              // Required since we have to compose parameters based on the operation and the path\n              operationParameters: composeParameters(['paths', pathName], method, path, operation)\n            };\n          }\n        });\n      });\n    });\n  }\n\n  return apiCache;\n};\n\n/**\n * Middleware for providing Swagger information to downstream middleware and request handlers.  For all requests that\n * match a Swagger path, 'req.swagger' will be provided with pertinent Swagger details.  Since Swagger 1.2 and 2.0\n * differ a bit, the structure of this object will change so please view the documentation below for more details:\n *\n *     https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swagger-metadata\n *\n * @param {object} rlOrSO - The Resource Listing (Swagger 1.2) or Swagger Object (Swagger 2.0)\n * @param {object[]} apiDeclarations - The array of API Declarations (Swagger 1.2)\n *\n * @returns the middleware function\n */\nexports = module.exports = function (rlOrSO, apiDeclarations) {\n  debug('Initializing swagger-metadata middleware');\n\n  var apiCache = processSwaggerDocuments(rlOrSO, apiDeclarations);\n  var swaggerVersion = cHelpers.getSwaggerVersion(rlOrSO);\n\n  if (_.isUndefined(rlOrSO)) {\n    throw new Error('rlOrSO is required');\n  } else if (!_.isPlainObject(rlOrSO)) {\n    throw new TypeError('rlOrSO must be an object');\n  }\n\n  if (swaggerVersion === '1.2') {\n    if (_.isUndefined(apiDeclarations)) {\n      throw new Error('apiDeclarations is required');\n    } else if (!_.isArray(apiDeclarations)) {\n      throw new TypeError('apiDeclarations must be an array');\n    }\n  }\n\n  return function swaggerMetadata (req, res, next) {\n    var method = req.method.toLowerCase();\n    var path = parseurl(req).pathname;\n    var cacheEntry;\n    var match;\n    var metadata;\n\n    cacheEntry = apiCache[path] || _.find(apiCache, function (metadata) {\n      match = metadata.re.exec(path);\n      return _.isArray(match);\n    });\n\n    debug('%s %s', req.method, req.url);\n    debug('  Is a Swagger path: %s', !_.isUndefined(cacheEntry));\n\n    // Request does not match an API defined in the Swagger document(s)\n    if (!cacheEntry) {\n      return next();\n    }\n\n    metadata = swaggerVersion === '1.2' ?\n      {\n        api: cacheEntry.api,\n        apiDeclaration: cacheEntry.apiDeclaration,\n        apiIndex: cacheEntry.apiIndex,\n        params: {},\n        resourceIndex: cacheEntry.resourceIndex,\n        resourceListing: cacheEntry.resourceListing\n      } :\n    {\n      apiPath : cacheEntry.apiPath,\n      path: cacheEntry.path,\n      params: {},\n      swaggerObject: cacheEntry.swaggerObject.resolved\n    };\n\n    if (_.isPlainObject(cacheEntry.operations[method])) {\n      metadata.operation = cacheEntry.operations[method].operation;\n      metadata.operationPath = cacheEntry.operations[method].operationPath;\n\n      if (swaggerVersion === '1.2') {\n        metadata.authorizations = metadata.operation.authorizations || cacheEntry.apiDeclaration.authorizations;\n      } else {\n        metadata.operationParameters = cacheEntry.operations[method].operationParameters;\n        metadata.security = metadata.operation.security || metadata.swaggerObject.security || [];\n      }\n    }\n\n    metadata.swaggerVersion = swaggerVersion;\n\n    req.swagger = metadata;\n\n    debug('  Is a Swagger operation: %s', !_.isUndefined(metadata.operation));\n\n    if (metadata.operation) {\n      // Process the operation parameters\n      return processOperationParameters(metadata, cacheEntry.keys, match, req, res, next, debug);\n    } else {\n      return next();\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/middleware/helpers.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n/* This module contains code that is reused in more than one of the Swagger middlewares */\n\nvar _ = require('lodash-compat');\nvar helpers = require('../lib/helpers');\nvar parseurl = require('parseurl');\nvar qs = require('qs');\n\nvar isModelType = module.exports.isModelType = function (spec, type) {\n  return spec.primitives.indexOf(type) === -1;\n};\n\nvar getParameterType = module.exports.getParameterType = function (schema) {\n  var type = schema.type;\n\n  if (!type && schema.schema) {\n    type = getParameterType(schema.schema);\n  }\n\n  if (!type) {\n    type = 'object';\n  }\n\n  return type;\n};\n\nvar isModelParameter = module.exports.isModelParameter = function (version, param) {\n  var spec = helpers.getSpec(version);\n  var type = getParameterType(param);\n  var isModel = false;\n\n  if (type === 'object' || isModelType(spec, type)) {\n    isModel = true;\n  } else if (type === 'array' && isModelType(spec, param.items ?\n                                             param.items.type || param.items.$ref :\n                                             undefined)) {\n    isModel = true;\n  }\n\n  return isModel;\n};\n\nmodule.exports.getParameterValue = function (version, parameter, pathKeys, match, req, debug) {\n  var defaultVal = version === '1.2' ? parameter.defaultValue : parameter.default;\n  var paramLocation = version === '1.2' ? parameter.paramType : parameter.in;\n  var paramType = getParameterType(parameter);\n  var val;\n\n  // Get the value to validate based on the operation parameter type\n  switch (paramLocation) {\n  case 'body':\n    val = req.body;\n\n    break;\n  case 'form':\n  case 'formData':\n    if (paramType.toLowerCase() === 'file') {\n      if (_.isArray(req.files)) {\n        val = _.find(req.files, function (file) {\n          return file.fieldname === parameter.name;\n        });\n      } else if (!_.isUndefined(req.files)) {\n        val = req.files[parameter.name] ? req.files[parameter.name] : undefined;\n      }\n\n      // Swagger does not allow an array of files\n      if (_.isArray(val)) {\n        val = val[0];\n      }\n    } else if (isModelParameter(version, parameter)) {\n      val = req.body;\n    } else {\n      val = req.body[parameter.name];\n    }\n\n    break;\n  case 'header':\n    val = req.headers[parameter.name.toLowerCase()];\n\n    break;\n  case 'path':\n    _.each(pathKeys, function (key, index) {\n      if (key.name === parameter.name) {\n        val = decodeURIComponent(match[index + 1]);\n      }\n    });\n\n    break;\n  case 'query':\n    val = _.get(req.query, parameter.name);\n\n    break;\n  }\n\n  debug('      Value provided: %s', !_.isUndefined(val));\n\n  // Use the default value when necessary\n  if (_.isUndefined(val) && !_.isUndefined(defaultVal)) {\n    val = defaultVal;\n  }\n\n  return val;\n};\n\nmodule.exports.parseQueryString = function(req) {\n  return req.url.indexOf('?') > -1 ? qs.parse(parseurl(req).query, {}) : {};\n};\n\nmodule.exports.debugError = function (err, debug) {\n  var reason = err.message.replace(/^.*validation failed: /, '');\n\n  reason = reason.charAt(0).toUpperCase() + reason.substring(1);\n\n  debug('  Reason: %s', reason);\n\n  if (err.failedValidation === true) {\n    if (err.results) {\n      debug('  Errors:');\n\n      _.each(err.results.errors, function (error, index) {\n        debug('    %d:', index);\n        debug('      code: %s', error.code);\n        debug('      message: %s', error.message);\n        debug('      path: %s', JSON.stringify(error.path));\n      });\n    }\n  }\n\n  if (err.stack) {\n    debug('  Stack:');\n\n    _.each(err.stack.split('\\n'), function (line, index) {\n      // Skip the first line since it's in the reasonx\n      if (index > 0) {\n        debug('  %s', line);\n      }\n    });\n  }\n};\n\nvar convertValue = module.exports.convertValue = function (value, schema, type) {\n  var original = value;\n\n  // Default to {}\n  if (_.isUndefined(schema)) {\n    schema = {};\n  }\n\n  // Try to find the type or default to 'object'\n  if (_.isUndefined(type)) {\n    type = getParameterType(schema);\n  }\n\n  // If there is no value, do not convert it\n  if (_.isUndefined(value)) {\n    return value;\n  }\n\n  // If there is an empty value and allowEmptyValue is true, return it\n  if (schema.allowEmptyValue && value === '') {\n    return value;\n  }\n\n  switch (type) {\n  case 'array':\n    if (_.isString(value)) {\n      switch (schema.collectionFormat) {\n      case 'csv':\n      case undefined:\n        try {\n          value = JSON.parse(value);\n        } catch (err) {\n          value = original;\n        }\n\n        if (_.isString(value)) {\n          value = value.split(',');\n        }\n        break;\n      case 'multi':\n        value = [value];\n        break;\n      case 'pipes':\n        value = value.split('|');\n        break;\n      case 'ssv':\n        value = value.split(' ');\n        break;\n      case 'tsv':\n        value = value.split('\\t');\n        break;\n      }\n    }\n\n    // Handle situation where the expected type is array but only one value was provided\n    if (!_.isArray(value)) {\n      value = [value];\n    }\n\n    value = _.map(value, function (item, index) {\n      var iSchema = _.isArray(schema.items) ? schema.items[index] : schema.items;\n\n      return convertValue(item, iSchema, iSchema ? iSchema.type : undefined);\n    });\n\n    break;\n\n  case 'boolean':\n    if (!_.isBoolean(value)) {\n      if (['false', 'true'].indexOf(value) === -1) {\n        value = original;\n      } else {\n        value = value === 'true' || value === true ? true : false;\n      }\n    }\n\n    break;\n\n  case 'integer':\n    if (!_.isNumber(value)) {\n      if (_.isString(value) && _.trim(value).length === 0) {\n        value = NaN;\n      }\n\n      value = Number(value);\n\n      if (isNaN(value)) {\n        value = original;\n      }\n    }\n\n    break;\n\n  case 'number':\n    if (!_.isNumber(value)) {\n      if (_.isString(value) && _.trim(value).length === 0) {\n        value = NaN;\n      }\n\n      value = Number(value);\n\n      if (isNaN(value)) {\n        value = original;\n      }\n    }\n\n    break;\n\n  case 'object':\n    if (_.isString(value)) {\n      try {\n        value = JSON.parse(value);\n      } catch (err) {\n        value = original;\n      }\n    }\n\n    break;\n\n  case 'string':\n    if (['date', 'date-time'].indexOf(schema.format) > -1 && !_.isDate(value)) {\n      value = new Date(value);\n\n      if (!_.isDate(value) || value.toString() === 'Invalid Date') {\n        value = original;\n      }\n    }\n\n    break;\n\n  }\n\n  return value;\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/middleware/swagger-router.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar _ = require('lodash-compat');\nvar cHelpers = require('../lib/helpers');\nvar debug = require('debug')('swagger-tools:middleware:router');\nvar fs = require('fs');\nvar mHelpers = require('./helpers');\nvar path = require('path');\n\nvar defaultOptions = {\n  controllers: {},\n  useStubs: false // Should we set this automatically based on process.env.NODE_ENV?\n};\nvar getHandlerName = function (req) {\n  var handlerName;\n\n  switch (req.swagger.swaggerVersion) {\n  case '1.2':\n    handlerName = req.swagger.operation.nickname;\n    break;\n\n  case '2.0':\n    if (req.swagger.operation['x-swagger-router-controller'] || req.swagger.path['x-swagger-router-controller']) {\n      handlerName = (req.swagger.operation['x-swagger-router-controller'] ?\n        req.swagger.operation['x-swagger-router-controller'] :\n        req.swagger.path['x-swagger-router-controller']) + '_' +\n        (req.swagger.operation.operationId ? req.swagger.operation.operationId : req.method.toLowerCase());\n    } else {\n      handlerName = req.swagger.operation.operationId;\n    }\n\n    break;\n  }\n\n  return handlerName;\n};\nvar handlerCacheFromDir = function (dirOrDirs) {\n  var handlerCache = {};\n  var jsFileRegex = /\\.(coffee|js)$/;\n  var dirs = [];\n\n  if (_.isArray(dirOrDirs)) {\n    dirs = dirOrDirs;\n  } else {\n    dirs.push(dirOrDirs);\n  }\n\n  debug('  Controllers:');\n\n  _.each(dirs, function (dir) {\n    _.each(fs.readdirSync(dir), function (file) {\n      var controllerName = file.replace(jsFileRegex, '');\n      var controller;\n\n      if (file.match(jsFileRegex)) {\n        controller = require(path.resolve(path.join(dir, controllerName)));\n\n        debug('    %s%s:',\n              path.resolve(path.join(dir, file)),\n              (_.isPlainObject(controller) ? '' : ' (not an object, skipped)'));\n\n        if (_.isPlainObject(controller)) {\n          _.each(controller, function (value, name) {\n            var handlerId = controllerName + '_' + name;\n\n            debug('      %s%s',\n                  handlerId,\n                  (_.isFunction(value) ? '' : ' (not a function, skipped)'));\n\n            // TODO: Log this situation\n\n            if (_.isFunction(value) && !handlerCache[handlerId]) {\n              handlerCache[handlerId] = value;\n            }\n          });\n        }\n      }\n    });\n  });\n\n  return handlerCache;\n};\nvar getMockValue = function (version, schema) {\n  var type = _.isPlainObject(schema) ? schema.type : schema;\n  var value;\n\n  if (!type) {\n    type = 'object';\n  }\n\n  switch (type) {\n  case 'array':\n    value = [getMockValue(version, _.isArray(schema.items) ? schema.items[0] : schema.items)];\n\n    break;\n\n  case 'boolean':\n    if (version === '1.2' && !_.isUndefined(schema.defaultValue)) {\n      value = schema.defaultValue;\n    } else if (version === '2.0' && !_.isUndefined(schema.default)) {\n      value = schema.default;\n    } else if (_.isArray(schema.enum)) {\n      value = schema.enum[0];\n    } else {\n      value = 'true';\n    }\n\n    // Convert value if necessary\n    value = value === 'true' || value === true ? true : false;\n\n    break;\n\n  case 'file':\n  case 'File':\n    value = 'Pretend this is some file content';\n\n    break;\n\n  case 'integer':\n    if (version === '1.2' && !_.isUndefined(schema.defaultValue)) {\n      value = schema.defaultValue;\n    } else if (version === '2.0' && !_.isUndefined(schema.default)) {\n      value = schema.default;\n    } else if (_.isArray(schema.enum)) {\n      value = schema.enum[0];\n    } else {\n      value = 1;\n    }\n\n    // Convert value if necessary\n    if (!_.isNumber(value)) {\n      value = parseInt(value, 10);\n    }\n\n    // TODO: Handle constraints and formats\n\n    break;\n\n  case 'object':\n    value = {};\n\n    _.each(schema.allOf, function (parentSchema) {\n      _.each(parentSchema.properties, function (property, propName) {\n        value[propName] = getMockValue(version, property);\n      });\n    });\n\n    _.each(schema.properties, function (property, propName) {\n      value[propName] = getMockValue(version, property);\n    });\n\n    break;\n\n  case 'number':\n    if (version === '1.2' && !_.isUndefined(schema.defaultValue)) {\n      value = schema.defaultValue;\n    } else if (version === '2.0' && !_.isUndefined(schema.default)) {\n      value = schema.default;\n    } else if (_.isArray(schema.enum)) {\n      value = schema.enum[0];\n    } else {\n      value = 1.0;\n    }\n\n    // Convert value if necessary\n    if (!_.isNumber(value)) {\n      value = parseFloat(value);\n    }\n\n    // TODO: Handle constraints and formats\n\n    break;\n\n  case 'string':\n    if (version === '1.2' && !_.isUndefined(schema.defaultValue)) {\n      value = schema.defaultValue;\n    } else if (version === '2.0' && !_.isUndefined(schema.default)) {\n      value = schema.default;\n    } else if (_.isArray(schema.enum)) {\n      value = schema.enum[0];\n    } else {\n      if (schema.format === 'date') {\n        value = new Date().toISOString().split('T')[0];\n      } else if (schema.format === 'date-time') {\n        value = new Date().toISOString();\n      } else {\n        value = 'Sample text';\n      }\n    }\n\n    break;\n  }\n\n  return value;\n};\nvar mockResponse = function (req, res, next, handlerName) {\n  var method = req.method.toLowerCase();\n  var operation = req.swagger.operation;\n  var sendResponse = function (err, response) {\n    if (err) {\n      debug('next with error: %j', err);\n      return next(err);\n    } else {\n      debug('send mock response: %s', response);\n\n      // Explicitly set the response status to 200 if not present (Issue #269)\n      if (_.isUndefined(req.statusCode)) {\n        res.statusCode = 200;\n      }\n\n      // Mock mode only supports JSON right now\n      res.setHeader('Content-Type', 'application/json');\n\n      return res.end(response);\n    }\n  };\n  var spec = cHelpers.getSpec(req.swagger.swaggerVersion);\n  var stubResponse = 'Stubbed response for ' + handlerName;\n  var apiDOrSO;\n  var responseType;\n\n  switch (req.swagger.swaggerVersion) {\n  case '1.2':\n    apiDOrSO = req.swagger.apiDeclaration;\n    responseType = operation.type;\n\n    break;\n\n  case '2.0':\n    apiDOrSO = req.swagger.swaggerObject;\n\n    if (method === 'post' && operation.responses['201']) {\n      responseType = operation.responses['201'];\n\n      res.statusCode = 201;\n    } else if (method === 'delete' && operation.responses['204']) {\n      responseType = operation.responses['204'];\n\n      res.statusCode = 204;\n    } else if (operation.responses['200']) {\n      responseType = operation.responses['200'];\n    } else if (operation.responses['default']) {\n      responseType = operation.responses['default'];\n    } else {\n      responseType = 'void';\n    }\n\n    break;\n  }\n\n  if (_.isPlainObject(responseType) || mHelpers.isModelType(spec, responseType)) {\n    if (req.swagger.swaggerVersion === '1.2') {\n      spec.composeModel(apiDOrSO, responseType, function (err, result) {\n        if (err) {\n          return sendResponse(undefined, err);\n        } else {\n          // Should we handle this differently as undefined typically means the model doesn't exist\n          return sendResponse(undefined, _.isUndefined(result) ?\n                                           stubResponse :\n                                           JSON.stringify(getMockValue(req.swagger.swaggerVersion, result)));\n        }\n      });\n    } else {\n      return sendResponse(undefined, JSON.stringify(getMockValue(req.swagger.swaggerVersion, responseType.schema || responseType)));\n    }\n  } else {\n    return sendResponse(undefined, getMockValue(req.swagger.swaggerVersion, responseType));\n  }\n};\nvar createStubHandler = function (req, res, next, handlerName) {\n  // TODO: Handle headers for 2.0\n  // TODO: Handle examples (per mime-type) for 2.0\n  // TODO: Handle non-JSON response types\n\n  return function stubHandler (req, res, next) {\n    mockResponse(req, res, next, handlerName);\n  };\n};\n\nvar send405 = function (req, res, next) {\n  var allowedMethods = [];\n  var err = new Error('Route defined in Swagger specification (' +\n                        (_.isUndefined(req.swagger.api) ? req.swagger.apiPath : req.swagger.api.path) +\n                        ') but there is no defined ' +\n                      (req.swagger.swaggerVersion === '1.2' ? req.method.toUpperCase() : req.method.toLowerCase()) + ' operation.');\n\n  if (!_.isUndefined(req.swagger.api)) {\n    _.each(req.swagger.api.operations, function (operation) {\n      allowedMethods.push(operation.method.toUpperCase());\n    });\n  } else {\n    _.each(req.swagger.path, function (operation, method) {\n      if (cHelpers.swaggerOperationMethods.indexOf(method.toUpperCase()) !== -1) {\n        allowedMethods.push(method.toUpperCase());\n      }\n    });\n  }\n\n  err.allowedMethods = allowedMethods;\n\n  res.setHeader('Allow', allowedMethods.sort().join(', '));\n  res.statusCode = 405;\n\n  return next(err);\n};\n\n/**\n * Middleware for using Swagger information to route requests to handlers.  Due to the differences between Swagger 1.2\n * and Swagger 2.0, the way in which your Swagger document(s) are annotated to work with this middleware differs as well\n * so please view the documentation below for more details:\n *\n *     https://github.com/apigee-127/swagger-tools/blob/master/docs/Middleware.md#swaggerrouteroptions\n *\n * This middleware also requires that you use the swagger-metadata middleware before this middleware.  This middleware\n * also makes no attempt to work around invalid Swagger documents.  If you would like to validate your requests using\n * the swagger-validator middleware, you must use it prior to using this middleware.\n *\n * @param {object} [options] - The middleware options\n * @param {(string|object|string[]} [options.controllers=./controllers] - If this is a string or string array, this is\n *                                                                        the path, or paths, to find the controllers\n *                                                                        in.  If it's an object, the keys are the\n *                                                                        controller \"name\" (as described above) and the\n *                                                                        value is a function.\n * @param {boolean} [options.useStubs=false] - Whether or not to stub missing controllers and methods\n *\n * @returns the middleware function\n */\nexports = module.exports = function (options) {\n  var handlerCache = {};\n\n  debug('Initializing swagger-router middleware');\n\n  // Set the defaults\n  options = _.defaults(options || {}, defaultOptions);\n\n  debug('  Mock mode: %s', options.useStubs === true ? 'enabled' : 'disabled');\n\n  if (_.isPlainObject(options.controllers)) {\n    debug('  Controllers:');\n\n    // Create the handler cache from the passed in controllers object\n    _.each(options.controllers, function (func, handlerName) {\n      debug('    %s', handlerName);\n\n      if (!_.isFunction(func)) {\n        throw new Error('options.controllers values must be functions');\n      }\n    });\n\n    handlerCache = options.controllers;\n  } else {\n    // Create the handler cache from the modules in the controllers directory\n    handlerCache = handlerCacheFromDir(options.controllers);\n  }\n\n  return function swaggerRouter (req, res, next) {\n    var operation = req.swagger ? req.swagger.operation : undefined;\n    var handler;\n    var handlerName;\n    var rErr;\n\n    debug('%s %s', req.method, req.url);\n    debug('  Will process: %s', _.isUndefined(operation) ? 'no' : 'yes');\n\n    if (req.swagger) {\n      if (operation) {\n        handlerName = getHandlerName(req);\n        handler = handlerCache[handlerName];\n\n        req.swagger.useStubs = options.useStubs;\n\n        debug('  Route handler: %s', handlerName);\n        debug('    Missing: %s', _.isUndefined(handler) ? 'yes' : 'no');\n        debug('    Ignored: %s', options.ignoreMissingHandlers === true ? 'yes' : 'no');\n        debug('    Using mock: %s', options.useStubs && _.isUndefined(handler) ? 'yes' : 'no');\n\n        if (_.isUndefined(handler) && options.useStubs === true) {\n          handler = handlerCache[handlerName] = createStubHandler(handlerName);\n        }\n\n        if (!_.isUndefined(handler)) {\n          try {\n            return handler(req, res, next);\n          } catch (err) {\n            rErr = err;\n\n            debug('Handler threw an unexpected error: %s\\n%s', err.message, err.stack);\n          }\n        } else if (options.ignoreMissingHandlers !== true) {\n          rErr = new Error('Cannot resolve the configured swagger-router handler: ' + handlerName);\n\n          res.statusCode = 500;\n        }\n      } else {\n        debug('  No handler for method: %s', req.method);\n\n        return send405(req, res, next);\n      }\n    }\n\n    if (rErr) {\n      mHelpers.debugError(rErr, debug);\n    }\n\n    return next(rErr);\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/middleware/swagger-security.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n'use strict';\n\nvar _ = require('lodash-compat');\nvar async = require('async');\nvar debug = require('debug')('swagger-tools:middleware:security');\nvar helpers = require('./helpers');\n\nvar getScopeOrAPIKey = function (req, secDef, secName, secReq) {\n  var swaggerVersion = req.swagger.swaggerVersion;\n  var apiKeyPropName = swaggerVersion === '1.2' ? secDef.keyname : secDef.name;\n  var apiKeyLocation = swaggerVersion === '1.2' ? secDef.passAs : secDef.in;\n  var scopeOrKey;\n\n  if (secDef.type === 'oauth2') {\n    if (swaggerVersion === '1.2') {\n      scopeOrKey = _.map(secReq[secName], function (scope) {\n        return scope.scope;\n      });\n    } else {\n      scopeOrKey = secReq[secName];\n    }\n  } else if (secDef.type === 'apiKey') {\n    if (apiKeyLocation === 'query') {\n      scopeOrKey = (req.query ? req.query : helpers.parseQueryString(req))[apiKeyPropName];\n    } else if (apiKeyLocation === 'header') {\n      scopeOrKey = req.headers[apiKeyPropName.toLowerCase()];\n    }\n  }\n\n  return scopeOrKey;\n};\nvar sendSecurityError = function (err, res, next) {\n  // Populate default values if not present\n  if (!err.code) {\n    err.code = 'server_error';\n  }\n\n  if (!err.statusCode) {\n    err.statusCode = 403;\n  }\n\n  if (err.headers) {\n    _.each(err.headers, function (header, name) {\n      res.setHeader(name, header);\n    });\n  }\n\n  res.statusCode = err.statusCode;\n\n  next(err);\n};\n\n/**\n * Middleware for using Swagger security information to authenticate requests.\n *\n * This middleware also requires that you use the swagger-metadata middleware before this middleware. It is recommended\n * that this middleware is included before swagger-validator and swagger-router. This makes no attempt to work around\n * invalid Swagger documents.\n *\n *\n * A SecurityImplementation is essentially middleware must include 2 exported methods:\n *   configure (SecurityDefinition)\n *   authorize (request, response, SecurityRequirement)\n *\n * @param {object} [options] - The middleware options\n *                 [options.{name}={handler}] - the keys match SecurityDefinition names and the associated values are\n *                                              functions that accept the following parameters: (request,\n *                                              securityDefinition, scopes, callback) where callback accepts one\n *                                              argument - an Error if unauthorized. The Error may include \"message\",\n *                                              \"state\", and \"code\" fields to be conveyed to the client in the response\n *                                              body and a \"headers\" field containing an object representing headers\n *                                              to be set on the response to the client. In addition, if the Error has\n *                                              a statusCode field, the response statusCode will be set to match -\n *                                              otherwise, the statusCode will be set to 403.\n *\n * @returns the middleware function\n */\nexports = module.exports = function (options) {\n  var handlers = options || {};\n\n  debug('Initializing swagger-security middleware');\n  debug('  Security handlers:%s', Object.keys(handlers).length > 0 ? '' : ' ' + Object.keys(handlers).length);\n\n  _.each(options, function (func, name) {\n    debug('    %s', name);\n  });\n\n  return function swaggerSecurity (req, res, next) {\n    var operation = req.swagger ? req.swagger.operation : undefined;\n    var securityReqs;\n\n    debug('%s %s', req.method, req.url);\n    debug('  Will process: %s', _.isUndefined(operation) ? 'no' : 'yes');\n\n    if (operation) {\n      securityReqs = req.swagger.swaggerVersion === '1.2' ?\n        // Global (path level), authorization support is not possible:\n        //   Not possible due to https://github.com/swagger-api/swagger-spec/issues/159\n        _.reduce(req.swagger.operation.authorizations, function (arr, authorization, name) {\n          var obj = {};\n\n          obj[name] = _.map(authorization, function (scope) {\n            return scope.scope;\n          });\n\n          return arr.concat(obj);\n        }, []) :\n      req.swagger.operation.security || req.swagger.swaggerObject.security;\n\n      if (securityReqs && securityReqs.length > 0) {\n        async.map(securityReqs, function (secReq, cb) { // logical OR - any one can allow\n          var secName;\n\n          async.map(Object.keys(secReq), function (name, cb) { // logical AND - all must allow\n            var secDef = req.swagger.swaggerVersion === '1.2' ?\n                  req.swagger.resourceListing.authorizations[name] :\n                  req.swagger.swaggerObject.securityDefinitions[name];\n            var handler = handlers[name];\n\n            secName = name;\n\n            if (!handler) {\n              return cb(new Error('unknown security handler: ' + name));\n            }\n\n            return handler(req, secDef, getScopeOrAPIKey(req, secDef, name, secReq), cb);\n          }, function (err) {\n            debug('    Security check (%s): %s', secName, _.isNull(err) ? 'allowed' : 'denied');\n\n            // swap normal err and result to short-circuit the logical OR\n            if (err) {\n              return cb(undefined, err);\n            }\n\n            return cb(new Error('OK'));\n          });\n        }, function (ok, errors) { // note swapped results\n          var allowed = !_.isNull(ok) && ok.message === 'OK';\n\n          debug('    Request allowed: %s', allowed);\n\n          if (allowed) {\n            return next();\n          }\n\n          return sendSecurityError(errors[0], res, next);\n        });\n      } else {\n        return next();\n      }\n    } else {\n      return next();\n    }\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/middleware/swagger-ui.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar _ = require('lodash-compat');\nvar debug = require('debug')('swagger-tools:middleware:ui');\nvar fs = require('fs');\nvar helpers = require('../lib/helpers');\nvar parseurl = require('parseurl');\nvar path = require('path');\nvar serveStatic = require('serve-static');\n\nvar defaultOptions = {\n  apiDocs: '/api-docs',\n  swaggerUi: '/docs'\n};\nvar staticOptions = {};\n\n/**\n * Middleware for serving the Swagger documents and Swagger UI.\n *\n * @param {object} rlOrSO - The Resource Listing (Swagger 1.2) or Swagger Object (Swagger 2.0)\n * @param {object[]} apiDeclarations - The array of API Declarations (Swagger 1.2)\n * @param {object} [options] - The configuration options\n * @param {string=/api-docs} [options.apiDocs] - The relative path to serve your Swagger documents from\n * @param {string=/docs} [options.swaggerUi] - The relative path to serve Swagger UI from\n * @param {string} [options.swaggerUiDir] - The filesystem path to your custom swagger-ui deployment to serve\n *\n * @returns the middleware function\n */\nexports = module.exports = function (rlOrSO, apiDeclarations, options) {\n  debug('Initializing swagger-ui middleware');\n\n  var swaggerVersion = helpers.getSwaggerVersion(rlOrSO);\n  var apiDocsCache = {}; // Swagger document endpoints cache\n  var apiDocsPaths = [];\n  var staticMiddleware;\n  var swaggerApiDocsURL;\n  var swaggerUiPath;\n\n  if (swaggerVersion !== '1.2') {\n    options = apiDeclarations;\n    apiDeclarations = [];\n  }\n\n  // Set the defaults\n  options = _.defaults(options || {}, defaultOptions);\n\n  if (_.isUndefined(rlOrSO)) {\n    throw new Error('rlOrSO is required');\n  } else if (!_.isPlainObject(rlOrSO)) {\n    throw new TypeError('rlOrSO must be an object');\n  }\n\n  if (swaggerVersion === '1.2') {\n    if (_.isUndefined(apiDeclarations)) {\n      throw new Error('apiDeclarations is required');\n    } else if (!_.isPlainObject(apiDeclarations)) {\n      throw new TypeError('apiDeclarations must be an object');\n    }\n  }\n\n  swaggerUiPath = options.swaggerUiDir ?\n    path.resolve(options.swaggerUiDir) :\n    path.join(__dirname, 'swagger-ui');\n\n  if (options.swaggerUiDir) {\n    if (!fs.existsSync(swaggerUiPath)) {\n      throw new Error('options.swaggerUiDir path does not exist: ' + swaggerUiPath);\n    } else if (!fs.statSync(swaggerUiPath).isDirectory()) {\n      throw new Error('options.swaggerUiDir path is not a directory: ' + swaggerUiPath);\n    }\n  }\n\n  staticMiddleware = serveStatic(swaggerUiPath, staticOptions);\n\n  // Sanitize values\n  if (options.apiDocs.charAt(options.apiDocs.length -1) === '/') {\n    options.apiDocs = options.apiDocs.substring(0, options.apiDocs.length - 1);\n  }\n\n  if (options.swaggerUi.charAt(options.swaggerUi.length -1) === '/') {\n    options.swaggerUi = options.swaggerUi.substring(0, options.swaggerUi.length - 1);\n  }\n\n  debug('  Using swagger-ui from: %s', options.swaggerUiDir ? swaggerUiPath : 'internal');\n  debug('  API Docs path: %s', options.apiDocs);\n\n  // Add the Resource Listing or SwaggerObject to the response cache\n  apiDocsCache[options.apiDocs] = JSON.stringify(rlOrSO, null, 2);\n\n  // Add API Declarations to the response cache\n  _.each(apiDeclarations, function (resource, resourcePath) {\n    var adPath = options.apiDocs + resourcePath;\n\n    // Respond with pretty JSON (Configurable?)\n    apiDocsCache[adPath] = JSON.stringify(resource, null, 2);\n\n    debug('    API Declaration path: %s', adPath);\n  });\n\n  apiDocsPaths = Object.keys(apiDocsCache);\n\n  debug('  swagger-ui path: %s', options.swaggerUi);\n\n  return function swaggerUI (req, res, next) {\n    var path = parseurl(req).pathname;\n    var isApiDocsPath = apiDocsPaths.indexOf(path) > -1 || (swaggerVersion !== '1.2' && path === options.apiDocsPath);\n    var isSwaggerUiPath = path === options.swaggerUi || path.indexOf(options.swaggerUi + '/') === 0;\n\n    if (_.isUndefined(swaggerApiDocsURL)) {\n      // Start with the original path\n      swaggerApiDocsURL = parseurl.original(req).pathname;\n\n      // Remove the part after the mount point\n      swaggerApiDocsURL = swaggerApiDocsURL.substring(0, swaggerApiDocsURL.indexOf(req.url));\n      \n      // Add the API docs path and remove any double dashes\n      swaggerApiDocsURL = ((options.swaggerUiPrefix ? options.swaggerUiPrefix : '') + swaggerApiDocsURL + options.apiDocs).replace(/\\/\\//g, '/'); \n    }\n\n    debug('%s %s', req.method, req.url);\n    debug('  Will process: %s', isApiDocsPath || isSwaggerUiPath ? 'yes' : 'no');\n\n    if (isApiDocsPath) {\n      debug('  Serving API Docs');\n\n      res.setHeader('Content-Type', 'application/json');\n\n      return res.end(apiDocsCache[path]);\n    } else if (isSwaggerUiPath) {\n      debug('  Serving swagger-ui');\n\n      res.setHeader('Swagger-API-Docs-URL', swaggerApiDocsURL);\n\n      if (path === options.swaggerUi || path === options.swaggerUi + '/') {\n        req.url = '/';\n      } else {\n        req.url = req.url.substring(options.swaggerUi.length);\n      }\n\n      return staticMiddleware(req, res, next);\n    }\n\n    return next();\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-swagger-tools/node_modules/swagger-tools/middleware/swagger-validator.js":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Apigee Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar _ = require('lodash-compat');\nvar async = require('async');\nvar cHelpers = require('../lib/helpers');\nvar debug = require('debug')('swagger-tools:middleware:validator');\nvar mHelpers = require('./helpers');\nvar validators = require('../lib/validators');\n\nvar sendData = function (swaggerVersion, res, data, encoding, skipped) {\n  // 'res.end' requires a Buffer or String so if it's not one, create a String\n  if (!(data instanceof Buffer) && !_.isString(data)) {\n    data = JSON.stringify(data);\n  }\n\n  if (skipped) {\n    if (_.isUndefined(res.getHeader('content-type'))) {\n      // This scenario only happens for a 204/304 response and there is no Content-Type\n      debug('    Validation: skipped (Cached response for \\'%d\\')', res.statusCode);\n    } else if (swaggerVersion === '1.2') {\n      debug('    Validation: skipped (No responseMessage definition)', res.statusCode);\n    } else {\n      debug('    Validation: skipped (No response definition)', res.statusCode);\n    }\n  } else {\n    debug('    Validation: succeeded');\n  }\n\n  res.end(data, encoding);\n};\n\nvar send400 = function (req, res, next, err) {\n  var currentMessage;\n  var validationMessage;\n\n  res.statusCode = 400;\n\n  // Format the errors to include the parameter information\n  if (err.failedValidation === true) {\n    currentMessage = err.message;\n    validationMessage = 'Parameter (' + err.paramName + ') ';\n\n    switch (err.code) {\n    case 'ENUM_MISMATCH':\n    case 'MAXIMUM':\n    case 'MAXIMUM_EXCLUSIVE':\n    case 'MINIMUM':\n    case 'MINIMUM_EXCLUSIVE':\n    case 'MULTIPLE_OF':\n    case 'INVALID_TYPE':\n      if (err.code === 'INVALID_TYPE' && err.message.split(' ')[0] === 'Value') {\n        validationMessage += err.message.split(' ').slice(1).join(' ');\n      } else {\n        validationMessage += 'is ' + err.message.charAt(0).toLowerCase() + err.message.substring(1);\n      }\n\n      break;\n\n    case 'ARRAY_LENGTH_LONG':\n    case 'ARRAY_LENGTH_SHORT':\n    case 'MAX_LENGTH':\n    case 'MIN_LENGTH':\n      validationMessage += err.message.split(' ').slice(1).join(' ');\n\n      break;\n\n    case 'MAX_PROPERTIES':\n    case 'MIN_PROPERTIES':\n      validationMessage += 'properties are ' + err.message.split(' ').slice(4).join(' ');\n\n      break;\n\n    default:\n      validationMessage += err.message.charAt(0).toLowerCase() + err.message.substring(1);\n    }\n\n    // Replace the message\n    err.message = 'Request validation failed: ' + validationMessage;\n\n    // Replace the stack message\n    err.stack = err.stack.replace(currentMessage, validationMessage);\n  }\n\n  return next(err);\n};\nvar validateValue = function (req, schema, path, val, callback) {\n  var document = req.swagger.apiDeclaration || req.swagger.swaggerObject;\n  var version = req.swagger.apiDeclaration ? '1.2' : '2.0';\n  var isModel = mHelpers.isModelParameter(version, schema);\n  var spec = cHelpers.getSpec(version);\n\n  val = mHelpers.convertValue(val, schema, mHelpers.getParameterType(schema));\n\n  try {\n    validators.validateSchemaConstraints(version, schema, path, val);\n  } catch (err) {\n    return callback(err);\n  }\n\n  if (isModel) {\n    if (_.isString(val)) {\n      try {\n        val = JSON.parse(val);\n      } catch (err) {\n        err.failedValidation = true;\n        err.message = 'Value expected to be an array/object but is not';\n\n        throw err;\n      }\n    }\n\n    async.map(schema.type === 'array' ? val : [val], function (aVal, oCallback) {\n      if (version === '1.2') {\n        spec.validateModel(document, '#/models/' + (schema.items ?\n                                                    schema.items.type || schema.items.$ref :\n                                                    schema.type), aVal, oCallback);\n      } else {\n        try {\n          validators.validateAgainstSchema(schema.schema ? schema.schema : schema, val);\n\n          oCallback();\n        } catch (err) {\n          oCallback(err);\n        }\n      }\n    }, function (err, allResults) {\n      if (!err) {\n        _.each(allResults, function (results) {\n          if (results && cHelpers.getErrorCount(results) > 0) {\n            err = new Error('Failed schema validation');\n\n            err.code = 'SCHEMA_VALIDATION_FAILED';\n            err.errors = results.errors;\n            err.warnings = results.warnings;\n            err.failedValidation = true;\n\n            return false;\n          }\n        });\n      }\n\n      callback(err);\n    });\n  } else {\n    callback();\n  }\n};\nvar wrapEnd = function (req, res, next) {\n  var operation = req.swagger.operation;\n  var originalEnd = res.end;\n  var vPath = _.cloneDeep(req.swagger.operationPath);\n  var swaggerVersion = req.swagger.swaggerVersion;\n\n  res.end = function (data, encoding) {\n    var schema = operation;\n    var val = data;\n    var responseCode;\n\n    // Replace 'res.end' with the original\n    res.end = originalEnd;\n\n    debug('  Response validation:');\n\n    // If the data is a buffer, convert it to a string so we can parse it prior to validation\n    if (val instanceof Buffer) {\n      val = data.toString(encoding);\n    }\n\n    // Express removes the Content-Type header from 204/304 responses which makes response validation impossible\n    if (_.isUndefined(res.getHeader('content-type')) && [204, 304].indexOf(res.statusCode) > -1) {\n      sendData(swaggerVersion, res, data, encoding, true);\n      return; // do NOT call next() here, doing so would execute remaining middleware chain twice\n    }\n\n    try {\n      // Validate the content type\n      try {\n        validators.validateContentType(req.swagger.apiDeclaration ?\n                                         req.swagger.apiDeclaration.produces :\n                                         req.swagger.swaggerObject.produces,\n                                       operation.produces, res);\n      } catch (err) {\n        err.failedValidation = true;\n\n        throw err;\n      }\n\n      if (_.isUndefined(schema.type)) {\n        if (schema.schema) {\n          schema = schema.schema;\n        } else if (swaggerVersion === '1.2') {\n          schema = _.find(operation.responseMessages, function (responseMessage, index) {\n            if (responseMessage.code === res.statusCode) {\n              vPath.push('responseMessages', index.toString());\n\n              responseCode = responseMessage.code;\n\n              return true;\n            }\n          });\n\n          if (!_.isUndefined(schema)) {\n            schema = schema.responseModel;\n          }\n        } else {\n          schema = _.find(operation.responses, function (response, code) {\n            if (code === (res.statusCode || 200).toString()) {\n              vPath.push('responses', code);\n\n              responseCode = code;\n\n              return true;\n            }\n          });\n\n          if (_.isUndefined(schema) && operation.responses.default) {\n            responseCode = 'default';\n            schema = operation.responses.default;\n\n            vPath.push('responses', 'default');\n          }\n        }\n      }\n\n      debug('    Response ' + (swaggerVersion === '1.2' ? 'message' : 'code') + ': ' + responseCode);\n\n      if (_.isUndefined(schema)) {\n        sendData(swaggerVersion, res, data, encoding, true);\n      } else {\n        validateValue(req, schema, vPath, val, function (err) {\n          if (err) {\n            throw err;\n          }\n          \n          sendData(swaggerVersion, res, data, encoding, false);\n        });\n      }\n    } catch (err) {\n      if (err.failedValidation) {\n        err.originalResponse = data;\n        err.message = 'Response validation failed: ' + err.message.charAt(0).toLowerCase() + err.message.substring(1);\n        \n        debug('    Validation: failed');\n\n        mHelpers.debugError(err, debug);\n      }\n\n      return next(err);\n    }\n  };\n};\n\n/**\n * Middleware for using Swagger information to validate API requests/responses.\n *\n * This middleware also requires that you use the swagger-metadata middleware before this middleware.  This middleware\n * also makes no attempt to work around invalid Swagger documents.\n *\n * @param {object} [options] - The middleware options\n * @param {boolean} [options.validateResponse=false] - Whether or not to validate responses\n *\n * @returns the middleware function\n */\nexports = module.exports = function (options) {\n  debug('Initializing swagger-validator middleware');\n\n  if (_.isUndefined(options)) {\n    options = {};\n  }\n\n  debug('  Response validation: %s', options.validateResponse === true ? 'enabled' : 'disabled');\n\n  return function swaggerValidator (req, res, next) {\n    var operation = req.swagger ? req.swagger.operation : undefined;\n    var paramIndex = 0;\n    var swaggerVersion = req.swagger ? req.swagger.swaggerVersion : undefined;\n    var paramName; // Here since we use it in the catch block\n    var paramPath; // Here since we use it in the catch block\n\n    debug('%s %s', req.method, req.url);\n    debug('  Will process: %s', _.isUndefined(operation) ? 'no' : 'yes');\n\n    if (!_.isUndefined(operation)) {\n      // If necessary, override 'res.end'\n      if (options.validateResponse === true) {\n        wrapEnd(req, res, next);\n      }\n\n      debug('  Request validation:');\n\n      // Validate the request\n      try {\n        // Validate the content type\n        validators.validateContentType(req.swagger.swaggerVersion === '1.2' ?\n                                         req.swagger.api.consumes :\n                                         req.swagger.swaggerObject.consumes,\n                                       operation.consumes, req);\n\n        async.map(swaggerVersion === '1.2' ?\n                  operation.parameters :\n                  req.swagger.operationParameters, function (parameter, oCallback) {\n                    var schema = swaggerVersion === '1.2' ? parameter : parameter.schema;\n                    var val;\n\n                    paramName = schema.name;\n                    paramPath = swaggerVersion === '1.2' ?\n                      req.swagger.operationPath.concat(['params', paramIndex.toString()]) :\n                      parameter.path;\n                    val = req.swagger.params[paramName].value;\n\n                    // Validate requiredness\n                    validators.validateRequiredness(val, schema.required);\n\n                    // Quick return if the value is not present\n                    if (_.isUndefined(val)) {\n                      return oCallback();\n                    }\n\n                    validateValue(req, schema, paramPath, val, oCallback);\n\n                    paramIndex++;\n                  }, function (err) {\n                    if (err) {\n                      throw err;\n                    } else {\n                      debug('    Validation: succeeded');\n\n                      return next();\n                    }\n                  });\n      } catch (err) {\n        if (err.failedValidation === true) {\n          if (!err.path) {\n            err.path = paramPath;\n          }\n\n          err.paramName = paramName;\n        }\n\n        debug('    Validation: failed');\n\n        mHelpers.debugError(err, debug);\n\n        return send400(req, res, next, err);\n      }\n    } else {\n      return next();\n    }\n  };\n};\n"}